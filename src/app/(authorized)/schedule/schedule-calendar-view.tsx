"use client";

import { Button } from "@/components/primitives/button";
import { useShiftRange } from "@/components/schedule/hooks/use-shift-range";
import { backgroundColors } from "@/components/ui/avatar";
import { ButtonGroup } from "@/components/ui/button-group";
import { useBreakpoint } from "@/hooks/use-breakpoint";
import { formatTimeRange } from "@/lib/schedule-fmt";
import { cn } from "@/lib/utils";
import { createPrng } from "@/utils/prngUtils";
import {
  type DayHeaderContentArg,
  type EventClickArg,
  type EventContentArg,
  type SlotLabelContentArg,
} from "@fullcalendar/core";
import dayGridPlugin from "@fullcalendar/daygrid";
import FullCalendar from "@fullcalendar/react";
import timeGridPlugin from "@fullcalendar/timegrid";
import CaretLeftIcon from "@public/assets/icons/caret-left.svg";
import CaretRightIcon from "@public/assets/icons/caret-right.svg";
import { endOfMonth, format, startOfMonth } from "date-fns";
import { Clock } from "lucide-react";
import { useEffect, useMemo, useRef, useState } from "react";
import useMeasure from "react-use-measure";
import { useSchedulePage } from "../../../components/schedule/schedule-page-context";
import { CalendarView, isOddDay, isSameDay } from "./dateUtils";
import "./page.scss";
import { useCalendarApi } from "./useCalendarApi";
import { useDayView } from "./useDayView";

const FIRST_DAY_OF_WEEK = 1;

export function ScheduleCalendarView() {
  const calendarRef = useRef<FullCalendar | null>(null);
  const calendarContainerRef = useRef<HTMLDivElement>(null);
  const isMdUp = useBreakpoint("md");
  const { calendarApi, next, prev, changeView, getDate, goToDate } =
    useCalendarApi(calendarRef);
  const { openAsideFor, selectedDate, setSelectedDate } = useSchedulePage();
  const { isDayView, renderDayViewHeader } = useDayView({
    calendarApi,
    next,
    prev,
    changeView,
    getDate,
    goToDate,
    calendarContainerRef,
    selectedDate,
    setSelectedDate,
  });

  const rangeStart = useMemo(() => startOfMonth(selectedDate), [selectedDate]);
  const rangeEnd = useMemo(() => endOfMonth(rangeStart), [rangeStart]);
  const { shifts: scheduleShifts } = useShiftRange({
    start: rangeStart,
    end: rangeEnd,
  });

  // Render calendar in appropriate view
  useEffect(() => {
    const api = calendarRef.current?.getApi();
    if (!api) return;

    queueMicrotask(() => {
      api.gotoDate(selectedDate);
    });
  }, [selectedDate]);

  useEffect(() => {
    const api = calendarRef.current?.getApi();
    if (!api) return;

    queueMicrotask(() => {
      if (isDayView) {
        api.changeView(CalendarView.Day, selectedDate);
      } else {
        api.changeView(CalendarView.Week);
      }
    });
  }, [selectedDate, isDayView]);

  // Keep FullCalendar width in sync with layout changes (e.g. opening/closing the aside).
  // ResizeObserver picks up the PageLayout aside animation and we debounce via rAF
  // so FullCalendar can recompute column widths without jitter.
  // This part was generated by ChatGPT to help with some animation nuances.
  useEffect(() => {
    const container = calendarContainerRef.current;
    if (!container) return;

    let frameId: number | null = null;
    let lastWidth = container.getBoundingClientRect().width;

    const observer = new ResizeObserver((entries) => {
      // only react to the first and only observed element
      const entry = entries[0];
      if (!entry) return;

      const { width } = entry.contentRect;
      // skip if nothing actually changed
      if (width === lastWidth) return;
      lastWidth = width;

      const api = calendarRef.current?.getApi();
      if (!api) return;

      // Wait until the next animation frame so updateSize runs once per frame
      // instead of every tiny resize while the aside animates
      if (frameId) cancelAnimationFrame(frameId);
      frameId = requestAnimationFrame(() => api.updateSize());
    });

    observer.observe(container);

    return () => {
      if (frameId) cancelAnimationFrame(frameId);
      observer.disconnect();
    };
  }, []);

  const handleNavAction = (navAction: "today" | "prev" | "next") => {
    const calendarApi = calendarRef.current?.getApi();
    if (!calendarApi) return;

    calendarApi[navAction]();
    setSelectedDate(calendarApi.getDate());
  };

  const renderNavBar = () => {
    return (
      <div className="flex w-full items-center justify-between border-b">
        <div className="flex items-center gap-4">
          <ButtonGroup>
            <Button variant="ghost" onClick={() => handleNavAction("today")}>
              Today
            </Button>
            <Button variant="ghost" onClick={() => handleNavAction("prev")}>
              <CaretLeftIcon />
            </Button>
            <Button variant="ghost" onClick={() => handleNavAction("next")}>
              <CaretRightIcon />
            </Button>
          </ButtonGroup>
          <div>
            {selectedDate.toLocaleDateString("en-US", {
              month: "long",
              year: "numeric",
            })}
          </div>
          {/* <Select>
            <SelectTrigger>
              <SelectValue placeholder={selectedDate.toLocaleDateString("en-US", {month: "long", year: "numeric"})} />
            </SelectTrigger>
            <SelectContent className="max-h-80 overflow-y-auto">
              {monthList.map((date: Date) => (
                <SelectItem key={date.toISOString()} value={date.toISOString()} className="cursor-pointer">
                  {date.toLocaleDateString("en-US", {month: "long", year: "numeric"})}
                </SelectItem>
              ))}
            </SelectContent>
          </Select> */}
        </div>
        {/* <div className="ml-auto">
          <Select value={currentView} onValueChange={(value) => handleViewChange(value as CalendarView)}>
            <SelectTrigger className="w-[150px]">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value={CalendarView.Week}>Week view</SelectItem>
              <SelectItem value={CalendarView.Day}>Day view</SelectItem>
            </SelectContent>
          </Select>
        </div> */}
        {/* <div>
          {!isDayView && <Select onValueChange={(v) => queueMicrotask(() => calendarRef.current?.getApi().changeView(v))}>
            <SelectTrigger className="w-[150px]">
              <SelectValue placeholder="Choose view" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="dayGridMonth">Month</SelectItem>
              <SelectItem value="timeGridWeek">Week</SelectItem>
              <SelectItem value="listView">list</SelectItem>
            </SelectContent>
          </Select>}
        </div> */}
      </div>
    );
  };

  const renderWeekHeader = (arg: DayHeaderContentArg) => {
    const date: Date = arg.date;
    const isToday = isSameDay(date, new Date());

    const dayName: string = date.toLocaleDateString("en-US", {
      weekday: "long",
    });
    const dayNameShort: string = date.toLocaleDateString("en-US", {
      weekday: "short",
    });
    const dayNum: number = date.getDate();

    return (
      <div className={cn("p-2 pt-3 text-left font-normal w-full")}>
        <div
          className={cn(
            "font-display text-lg",
            isToday && "font-bold text-primary",
          )}
        >
          {dayNum}
        </div>
        <div className={cn("truncate", isToday && "font-bold text-primary")}>
          {isMdUp ? dayName : dayNameShort}
        </div>
      </div>
    );
  };

  const renderSlotLabel = (ctx: SlotLabelContentArg) => {
    return (
      <div className="pl-2 pr-2">
        <span className={cn("font-medium")}>{format(ctx.date, "h")}</span>
        <span className="pl-0.5 align-[0.5px] text-muted-foreground text-xs">
          {format(ctx.date, "a")}
        </span>
      </div>
    );
  };

  const handleEventClick = (info: EventClickArg) => {
    openAsideFor(info.event.id);
    setSelectedDate(info.event.start!);
  };

  return (
    <>
      {renderNavBar()}
      {isDayView && renderDayViewHeader()}
      <div
        style={
          {
            "--fc-event-bg-color": "var(--card)",
            "--fc-event-border-color": "var(--border)",
            "--fc-event-text-color": "var(--card-foregroud)",
            "--fc-event-selected-overlay-color": "rgba(0, 0, 0, 0.05)",
            "--fc-now-indicator-color": "#FF4146",
            "--fc-today-bg-color":
              "color-mix(in srgb, var(--primary) 10%, transparent)",
          } as React.CSSProperties
        }
        className={cn(isDayView ? "pl-3" : "pl-9")}
        ref={calendarContainerRef}
      >
        <FullCalendar
          ref={calendarRef}
          eventDisplay="list-item"
          plugins={[dayGridPlugin, timeGridPlugin]}
          initialView={CalendarView.Week}
          headerToolbar={false}
          dayHeaderContent={(arg) => {
            if (isDayView) return null;
            if (arg.view.type === CalendarView.Month)
              return <div>{arg.text}</div>;

            return renderWeekHeader(arg);
          }}
          slotLabelContent={renderSlotLabel}
          dayHeaderClassNames={(ctx) =>
            cn(
              "overflow-hidden [&>*_>*]:!p-0 [&>*_>*]:!block [&>*_>*]:!max-w-full",
              isSameDay(ctx.date, new Date()) &&
                "!border-b-2 !border-b-primary",
              !isDayView && "[&:nth-child(2)]:!border-l-0",
              !isDayView &&
                isOddDay(ctx.date.getDay(), FIRST_DAY_OF_WEEK) &&
                "bg-muted",
            )
          }
          dayCellClassNames={(ctx) =>
            cn(
              !isDayView && "[&:nth-child(2)]:!border-l-0",
              !isDayView &&
                isOddDay(ctx.date.getDay(), FIRST_DAY_OF_WEEK) &&
                "bg-muted",
            )
          }
          eventClassNames={"!shadow mr-[2px] my-[1px] !rounded-sm"}
          eventContent={(ctx) => <CalendarEventContext ctx={ctx} />}
          height="auto"
          slotMinTime="07:00:00"
          nowIndicator
          nowIndicatorClassNames={(ctx) =>
            cn(
              ctx.isAxis &&
                "!m-0 !border-none -translate-y-[calc(50%-1px)] bg-(--fc-now-indicator-color) px-1.5 text-sm text-primary-foreground rounded-full right-1 !left-[unset]",
            )
          }
          nowIndicatorContent={(ctx) => ctx.isAxis && format(ctx.date, "h:mm")}
          allDaySlot={false}
          eventClick={handleEventClick}
          firstDay={FIRST_DAY_OF_WEEK}
          events={scheduleShifts.map((shift) => ({
            id: shift.id,
            title: shift.className,
            start: shift.startAt,
            end: shift.endAt,
          }))}
        />
      </div>
    </>
  );
}

function CalendarEventContext({ ctx: { event } }: { ctx: EventContentArg }) {
  const color = useMemo(() => {
    const prng = createPrng(event.title);
    return prng.shuffle(backgroundColors)[0]!;
  }, [event.title]);

  const [innerEventRef, innerEventBounds] = useMeasure();
  const [titleRef, titleBounds] = useMeasure();
  const [innerEventHeight, setInnerEventHeight] = useState(0);
  const [titleHeight, setTitleHeight] = useState(0);
  useEffect(() => {
    console.log(innerEventBounds.height);
    if (innerEventBounds.height) setInnerEventHeight(innerEventBounds.height);
  }, [innerEventBounds.height]);
  useEffect(() => {
    if (titleBounds.height) setTitleHeight(titleBounds.height);
  }, [titleBounds.height]);

  const titleLineHeight =
    16 /* 1rem */ * 0.875 /* font-size */ * 1.35; /* line-height */
  const mostTitleLines = Math.floor(innerEventHeight / titleLineHeight);

  const timeLineHeight = 3 /* size-3 */ * 4; /* 0.25rem */
  const hideTime = innerEventHeight < titleHeight + timeLineHeight;

  return (
    <div className={cn("flex flex-row max-w-full gap-1 h-full p-1 pb-3")}>
      <div
        style={{ "--avatar-bg": color } as React.CSSProperties}
        className={cn(
          "w-1.5 h-[min(90%,4rem)] translate-0 shrink-0 rounded bg-primary",
          "bg-(--avatar-bg)",
        )}
      />
      <div
        ref={innerEventRef}
        className="flex flex-col min-w-0 text-foreground w-full @container-[size]"
      >
        <span
          ref={titleRef}
          style={
            {
              "--line-clamp": mostTitleLines,
            } as React.CSSProperties
          }
          lang="en"
          className={cn(
            "shrink-0 text-sm break-words hyphens-auto",
            // This is the equialent of line-clamp-[--line-clamp]
            // however, this is not legal in tailwind so we have to do this workaround
            "overflow-hidden [display:-webkit-box] [-webkit-box-orient:vertical] [-webkit-line-clamp:var(--line-clamp)]",
          )}
        >
          {event.title}
        </span>
        <div
          className={cn(
            "flex gap-1 text-muted-foreground",
            hideTime && "hidden",
          )}
        >
          <Clock className="inline size-3" />
          <span className="truncate leading-3 text-xs">
            {formatTimeRange(event.start!, event.end!)}
          </span>
        </div>
      </div>
    </div>
  );
}
