"use client";

import { backgroundColors } from "@/components/ui/avatar";
import { useBreakpoint } from "@/hooks/use-breakpoint";
import { formatTimeRange } from "@/lib/schedule-fmt";
import { cn } from "@/lib/utils";
import { createPrng } from "@/utils/prngUtils";
import {
  type CalendarOptions,
  type DayHeaderContentArg,
  type EventContentArg,
  type SlotLabelContentArg,
} from "@fullcalendar/core";
import dayGridPlugin from "@fullcalendar/daygrid";
import FullCalendarComponent from "@fullcalendar/react";
import timeGridPlugin from "@fullcalendar/timegrid";
import { format, addHours } from "date-fns";
import { Clock } from "lucide-react";
import { useEffect, useEffectEvent, useMemo, useRef, useState } from "react";
import useMeasure from "react-use-measure";
import {
  CalendarView,
  isOddDay,
  isSameDay,
} from "../../app/(authorized)/schedule/dateUtils";
import { DAYVIEW_TRIGGER_WIDTH_PX, FIRST_DAY_OF_WEEK } from "./constants";
import { DayViewHeader } from "./day-view-header";
import { useFullCalendarContext } from "./fullcalendar-context";
import { FullCalendarDropShadowStyleOverrides } from "./fullcalendar.css.tsx";
import "./fullcalendar.css";

export function FullCalendar({
  onDateChange,
  className,
  ...opts
}: CalendarOptions & {
  className?: string;
  onDateChange?: (date: Date) => void;
}) {
  const { calendarRef, calendarApi } = useFullCalendarContext();

  // Keep FullCalendar width in sync with layout changes (e.g. opening/closing the aside).
  // ResizeObserver picks up the PageLayout aside animation and we debounce via rAF
  // so FullCalendar can recompute column widths without jitter.
  // This part was generated by ChatGPT to help with some animation nuances.
  const calendarContainerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const container = calendarContainerRef.current;
    if (!container) return;

    let frameId: number | null = null;
    let lastWidth = container.getBoundingClientRect().width;

    const observer = new ResizeObserver((entries) => {
      // only react to the first and only observed element
      const entry = entries[0];
      if (!entry) return;

      const { width } = entry.contentRect;
      // skip if nothing actually changed
      if (width === lastWidth) return;
      lastWidth = width;

      const api = calendarRef.current?.getApi();
      if (!api) return;

      // Wait until the next animation frame so updateSize runs once per frame
      // instead of every tiny resize while the aside animates
      if (frameId) cancelAnimationFrame(frameId);
      frameId = requestAnimationFrame(() => {
        api.updateSize();
      });
    });

    observer.observe(container);

    return () => {
      if (frameId) cancelAnimationFrame(frameId);
      observer.disconnect();
    };
  }, []);

  // The week vs day view is controlled by the width of the element.
  // Week view looks bad on small widths so we force a switch to day view.
  useEffect(() => {
    const container = calendarContainerRef.current;
    if (!container || !calendarApi) return;

    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (!entry) return;
      // This includes padding
      const width = entry.borderBoxSize[0]?.inlineSize;
      if (!width) return;

      queueMicrotask(() => {
        if (
          width < DAYVIEW_TRIGGER_WIDTH_PX &&
          calendarApi.view.type === CalendarView.Week
        ) {
          calendarApi.changeView(CalendarView.Day);
        } else if (
          width >= DAYVIEW_TRIGGER_WIDTH_PX &&
          calendarApi.view.type === CalendarView.Day
        ) {
          calendarApi.changeView(CalendarView.Week);
        }
      });
    });

    observer.observe(container);
    return () => observer.disconnect();
  }, [calendarContainerRef, calendarApi]);

  return (
    <div
      style={
        {
          "--fc-event-bg-color": "var(--card)",
          "--fc-event-border-color": "var(--border)",
          "--fc-event-text-color": "var(--card-foreground)",
          "--fc-event-selected-overlay-color": "rgba(0, 0, 0, 0.05)",
          "--fc-now-indicator-color": "#FF4146",
          "--fc-today-bg-color":
            "color-mix(in srgb, var(--primary) 10%, transparent)",
        } as React.CSSProperties
      }
      className={cn("h-full", className)}
      ref={calendarContainerRef}
    >
      <FullCalendarDropShadowStyleOverrides />
      <FullCalendarComponent
        ref={calendarRef}
        eventDisplay="list-item"
        plugins={[dayGridPlugin, timeGridPlugin]}
        initialView={CalendarView.Week}
        scrollTimeReset={false}
        scrollTime={
          // Initialize the view to 2hr before the now indicator
          addHours(new Date(), -2).toLocaleTimeString("en-US", {
            hourCycle: "h24",
          })
        }
        height={"100%"}
        headerToolbar={false}
        dayHeaderContent={(ctx) => {
          if (ctx.view.type === CalendarView.Month)
            return <div>{ctx.text}</div>;
          if (ctx.view.type === CalendarView.Day) return <DayViewHeader />;
          return <WeekHeaderContent ctx={ctx} />;
        }}
        slotLabelContent={(ctx: SlotLabelContentArg) => (
          <div className="pl-2 pr-2">
            <span className={cn("font-medium")}>{format(ctx.date, "h")}</span>
            <span className="pl-0.5 align-[0.5px] text-muted-foreground text-xs">
              {format(ctx.date, "a")}
            </span>
          </div>
        )}
        dayHeaderClassNames={(ctx) =>
          cn(
            "overflow-hidden [&>*_>*]:p-0! [&>*_>*]:block! [&>*_>*]:max-w-full!",
            ctx.view.type !== CalendarView.Day &&
              cn(
                "[&:nth-child(2)]:border-l-0!",
                isSameDay(ctx.date, new Date()) &&
                  "overflow-visible relative after:content-[''] after:absolute after:left-[-1px] after:right-[-1px] after:bottom-[-1px] after:h-[2px] after:bg-primary after:pointer-events-none",
                isOddDay(ctx.date.getDay(), FIRST_DAY_OF_WEEK) && "bg-muted",
              ),
          )
        }
        dayCellClassNames={(ctx) =>
          cn(
            ctx.view.type !== CalendarView.Day &&
              "[&:nth-child(2)]:border-l-0!",
            ctx.view.type !== CalendarView.Day &&
              isOddDay(ctx.date.getDay(), FIRST_DAY_OF_WEEK) &&
              "bg-muted",
          )
        }
        eventClassNames={"shadow! border! mr-[2px] my-[1px] rounded-sm!"}
        eventContent={(ctx) => <CalendarEventContent ctx={ctx} />}
        nowIndicator
        nowIndicatorClassNames={(ctx) =>
          cn(
            ctx.isAxis &&
              "m-0! border-none! -translate-y-[calc(50%-1px)] bg-(--fc-now-indicator-color) px-1.5 text-sm text-primary-foreground rounded-full right-1 left-[unset]!",
          )
        }
        nowIndicatorContent={(ctx) => ctx.isAxis && format(ctx.date, "h:mm")}
        allDaySlot={false}
        firstDay={FIRST_DAY_OF_WEEK}
        {...opts}
      />
    </div>
  );
}

function WeekHeaderContent({ ctx: { date } }: { ctx: DayHeaderContentArg }) {
  const isToday = isSameDay(date, new Date());
  const isMdUp = useBreakpoint("md");

  const dayName: string = date.toLocaleDateString("en-US", {
    weekday: "long",
  });
  const dayNameShort: string = date.toLocaleDateString("en-US", {
    weekday: "short",
  });
  const dayNum: number = date.getDate();

  return (
    <div className={cn("p-2 pt-3 text-left font-normal w-full")}>
      <div
        className={cn(
          "font-display text-lg",
          isToday && "font-bold text-primary",
        )}
      >
        {dayNum}
      </div>
      <div className={cn("truncate", isToday && "font-bold text-primary")}>
        {isMdUp ? dayName : dayNameShort}
      </div>
    </div>
  );
}

function CalendarEventContent({ ctx: { event } }: { ctx: EventContentArg }) {
  const color = useMemo(() => {
    const prng = createPrng(event.title);
    return prng.shuffle(backgroundColors)[0]!;
  }, [event.title]);

  const [innerEventRef, innerEventBounds] = useMeasure();
  const [titleRef, titleBounds] = useMeasure();
  const [innerEventHeight, setInnerEventHeight] = useState(0);
  const [titleHeight, setTitleHeight] = useState(0);

  useEffect(() => {
    if (innerEventBounds.height) setInnerEventHeight(innerEventBounds.height);
  }, [innerEventBounds.height]);
  useEffect(() => {
    if (titleBounds.height) setTitleHeight(titleBounds.height);
  }, [titleBounds.height]);

  const titleLineHeight =
    16 /* 1rem */ * 0.875 /* font-size */ * 1.35; /* line-height */
  const mostTitleLines = Math.max(
    1,
    Math.floor(innerEventHeight / titleLineHeight),
  );

  const timeLineHeight = 3 /* size-3 */ * 4; /* 0.25rem */
  const hideTime = innerEventHeight < titleHeight + timeLineHeight;

  return (
    <div
      className={cn(
        "flex flex-row max-w-full gap-1 h-full px-1 overflow-hidden",
        innerEventHeight === 0 && "opacity-0",
        mostTitleLines === 1 ? "py-0.5" : "pt-1 pb-3",
      )}
    >
      <div
        style={{ "--avatar-bg": color } as React.CSSProperties}
        className={cn(
          "w-1.5 border-box translate-0 shrink-0 rounded bg-primary",
          mostTitleLines === 1 ? "h-full" : "h-[min(70%,4rem)]",
          "bg-(--avatar-bg)",
        )}
      />
      <div
        ref={innerEventRef}
        className="flex flex-col min-w-0 text-foreground w-full @container-[size]"
      >
        <span
          ref={titleRef}
          style={{ "--line-clamp": mostTitleLines } as React.CSSProperties}
          lang="en"
          className={cn(
            "shrink-0 text-sm wrap-break-word hyphens-auto",
            mostTitleLines === 1 && "leading-[0.85]",
            // This is the equivalent of line-clamp-[--line-clamp]
            // however, this is not legal in tailwind so we have to do this workaround
            "overflow-hidden [display:-webkit-box] [-webkit-box-orient:vertical] [-webkit-line-clamp:var(--line-clamp)]",
          )}
        >
          {event.title}
        </span>
        <div
          className={cn(
            "flex gap-1 text-muted-foreground",
            hideTime && "hidden",
          )}
        >
          <Clock className="inline size-3" />
          <span className="truncate leading-3 text-xs">
            {formatTimeRange(event.start!, event.end!)}
          </span>
        </div>
      </div>
    </div>
  );
}
