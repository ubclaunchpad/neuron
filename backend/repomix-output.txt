This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-27T19:35:39.216Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  common/
    databaseModels.ts
    interfaces.ts
    types.ts
  config/
    authCheck.ts
    database.ts
    fileUpload.ts
    models.ts
    queryBuilder.ts
  controllers/
    adminController.ts
    authController.ts
    availabilityController.ts
    classController.ts
    imageController.ts
    instructorController.ts
    scheduleController.ts
    shiftController.ts
    userController.ts
    volunteerController.ts
  models/
    availabilityModel.ts
    classModel.ts
    imageModel.ts
    instructorModel.ts
    scheduleModel.ts
    shiftModel.ts
    userModel.ts
    volunteerModel.ts
  routes/
    adminRoutes.ts
    authRoutes.ts
    classRoutes.ts
    imageRoutes.ts
    instructorRoutes.ts
    routes.ts
    scheduleRoutes.ts
    shiftRoutes.ts
    userRoutes.ts
    volunteerRoutes.ts
  utils/
    routeUtils.ts
  index.ts
.example.env
.gitignore
generate-types.js
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/common/databaseModels.ts
================
import { RowDataPacket } from "mysql2";

/*
* This file was generated by a tool.
* Rerun sql-ts to regenerate this file.
*/
export interface AvailabilityDB extends RowDataPacket {
  'availability_id'?: number;
  'day': number;
  'end_time': string;
  'fk_volunteer_id': string;
  'start_time': string;
}
export interface ClassDB extends RowDataPacket {
  'category'?: string | null;
  'class_id'?: number;
  'class_name': string;
  'end_date': string;
  'fk_image_id'?: string | null;
  'fk_instructor_id': string;
  'instructions'?: string | null;
  'start_date': string;
  'subcategory'?: string | null;
  'zoom_link': string;
}
export interface ClassPreferenceDB extends RowDataPacket {
  'class_rank'?: number | null;
  'fk_schedule_id'?: number | null;
  'fk_volunteer_id'?: string | null;
}
export interface ImageDB extends RowDataPacket {
  'image': Buffer;
  'image_id': string;
}
export interface InstructorDB extends RowDataPacket {
  'email': string;
  'f_name': string;
  'instructor_id': string;
  'l_name': string;
}
export interface PendingShiftCoverageDB extends RowDataPacket {
  'pending_volunteer': string;
  'request_id': number;
}
export interface ScheduleDB extends RowDataPacket {
  'active'?: any;
  'day': number;
  'end_time': string;
  'fk_class_id': number;
  'frequency'?: string;
  'schedule_id'?: number;
  'start_time': string;
}
export interface ShiftCoverageRequestDB extends RowDataPacket {
  'covered_by'?: string | null;
  'fk_shift_id': number;
  'request_id'?: number;
}
export interface ShiftDB extends RowDataPacket {
  'checked_in'?: any;
  'duration': number;
  'fk_schedule_id': number;
  'fk_volunteer_id': string;
  'shift_date': string;
  'shift_id'?: number;
}
export interface UserDB extends RowDataPacket {
  'created_at'?: Date | null;
  'email': string;
  'f_name': string;
  'fk_image_id'?: string | null;
  'l_name': string;
  'password': string;
  'role': 'volunteer' | 'admin' | 'instructor';
  'user_id': string;
}
export interface VolunteerClassDB extends RowDataPacket {
  'fk_class_id': number;
  'fk_volunteer_id': string;
}
export interface VolunteerScheduleDB extends RowDataPacket {
  'fk_schedule_id': number;
  'fk_volunteer_id': string;
}
export interface VolunteerDB extends RowDataPacket {
  'active'?: any;
  'bio'?: string | null;
  'city'?: string | null;
  'fk_user_id'?: string | null;
  'p_name'?: string | null;
  'p_time_ctmt'?: number;
  'phone_number'?: string | null;
  'pronouns'?: string | null;
  'province'?: string | null;
  'total_hours'?: number;
  'volunteer_id': string;
}

================
File: src/common/interfaces.ts
================
export enum Role {
    admin = 'admin',
    volunteer = 'volunteer',
    instructor = 'instructor'
};

================
File: src/common/types.ts
================
import { NextFunction, Request, Response } from "express";
import { ValidationChain } from "express-validator";
import { UserDB } from "./databaseModels.js";

export type AuthenticatedRequest = Request & {
    user?: UserDB
}

/**
 * Interface for the decoded data from a JWT
 */
export interface DecodedJwtPayload {
    user_id: string;
}

export type HTTPMethod = 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head';

export interface RouteGroup {
    path: string;
    validation?: ValidationChain[];
    middleware?: Array<(req: Request, res: Response, next: NextFunction) => void>;
    children: RouteDefinition[];
}

export interface RouteEndpoint {
    path: string;
    validation?: ValidationChain[];
    middleware?: Array<(req: Request, res: Response, next: NextFunction) => void>;
    method: HTTPMethod;
    action: (req: Request, res: Response, next: NextFunction) => Promise<any>;
}

export type RouteDefinition = RouteGroup | RouteEndpoint;

================
File: src/config/authCheck.ts
================
import dotenv from "dotenv";
import { NextFunction, Request, Response } from "express";
import { Role } from "../common/interfaces.js";
import {
    AuthenticatedRequest
} from "../common/types.js";

// Load environment variables
dotenv.config();

// Define environment variables
const TOKEN_SECRET = process.env.TOKEN_SECRET;

async function isAuthorized(
    req: Request,
    res: Response,
    next: NextFunction
): Promise<any> {
    return next();

    // // Get the token from the request body
    // const bearer = req.headers.authorization;

    // // Grab token from "Bearer {token}"
    // const token = bearer?.match(/Bearer (.+)/)?.[1];

    // // If the token is not provided, return an error message
    // if (!token) {
    //     return res.status(401).json({
    //         error: "Unauthorized",
    //     });
    // }

    // if (!TOKEN_SECRET) {
    //     return res.status(500).json({
    //         error: "Server configuration error: TOKEN_SECRET is not defined",
    //     });
    // }

    // try {
    //     // Verify the token
    //     const decoded = jwt.verify(token, TOKEN_SECRET) as DecodedJwtPayload;
        
    //     const result = await userModel.getUserById(decoded.user_id);

    //     // Attach the user to the request
    //     (req as AuthenticatedRequest).user = result;

    //     // Call the next function
    //     return next();
    // } catch (err) {
    //     return res.status(401).json({
    //         error: "The token is either invalid or has expired",
    //     });
    // }
}

async function isAdmin(
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
): Promise<any> {
    if (req.user!.role !== Role.admin) {
        return res.status(403).json({
            error: "Forbidden",
        });
    }

    next();
}

export { isAdmin, isAuthorized };

================
File: src/config/database.ts
================
import { config } from "dotenv";
import mysql, { Pool, PoolOptions } from 'mysql2/promise';

config();

const configuration: PoolOptions = {
  host: process.env.RDS_HOSTNAME || '',
  user: process.env.RDS_USERNAME || '',
  password: process.env.RDS_PASSWORD || '',
  database: process.env.RDS_DB || '',
  port: process.env.RDS_PORT ? parseInt(process.env.RDS_PORT, 10) : 3306, // Default to port 3306 if not specified
  typeCast: (_, next) => {
    // Turn null columns into undefined
    const value = next();
    return value === null ? undefined : value;
  },
};

const connectionPool: Pool = mysql.createPool(configuration);

export default connectionPool;

================
File: src/config/fileUpload.ts
================
import multer from "multer";
import path from "path";

const storage = multer.memoryStorage();

// multer for uploading images
export const imageUploadMiddleware = multer({ 
    storage,
    fileFilter: (_req, file, cb) => {
        // Allowed ext
        const allowedExts = ['jpeg', 'jpg', 'png', 'gif'];
        // Check ext
        const extname = allowedExts.includes(path.extname(file.originalname).replace('.', '').toLowerCase());
        // Check mime
        const mimetype = allowedExts.map(ext => `image/${ext}`).includes(file.mimetype);

        if(mimetype && extname){
            cb(null, true);
        } else {
            cb(null, false);
        }
    }
}).single('image');

================
File: src/config/models.ts
================
import AvailabilityModel from "../models/availabilityModel.js";
import ClassesModel from "../models/classModel.js";
import ImageModel from "../models/imageModel.js";
import InstructorModel from "../models/instructorModel.js";
import ScheduleModel from "../models/scheduleModel.js";
import ShiftModel from "../models/shiftModel.js";
import UserModel from "../models/userModel.js";
import VolunteerModel from "../models/volunteerModel.js";

export const availabilityModel = new AvailabilityModel();
export const classesModel = new ClassesModel();
export const imageModel = new ImageModel();
export const instructorModel = new InstructorModel();
export const scheduleModel = new ScheduleModel();
export const shiftModel = new ShiftModel();
export const userModel = new UserModel();
export const volunteerModel = new VolunteerModel();

================
File: src/config/queryBuilder.ts
================
import knex from "knex";

const queryBuilder = knex({ client: 'mysql' });

export default queryBuilder;

================
File: src/controllers/adminController.ts
================
import { Response } from "express";
import { VolunteerDB } from "../common/databaseModels.js";
import { AuthenticatedRequest } from "../common/types.js";
import { volunteerModel } from "../config/models.js";


async function getUnverifiedVolunteers(
    req: AuthenticatedRequest,
    res: Response
) {
    const unverifiedVolunteers = await volunteerModel.getUnverifiedVolunteers();

    res.status(200).json({
        volunteers: unverifiedVolunteers,
    });
}

async function verifyVolunteer(
    req: AuthenticatedRequest,
    res: Response
): Promise<any> {
    // Get the token from the request parameters
    const volunteer_id = req.body.volunteer_id;

    // Update the user's active status
    await volunteerModel.updateVolunteer(volunteer_id, {
        active: true,
    } as VolunteerDB);
    
    return res.status(200).json({
        message: "User verified successfully",
    });
}

export { getUnverifiedVolunteers, verifyVolunteer };

================
File: src/controllers/authController.ts
================
import bcrypt from "bcrypt";
import dotenv from "dotenv";
import { Request, Response } from "express";
import jwt from "jsonwebtoken";
import nodemailer from "nodemailer";
import { v4 as uuidv4 } from "uuid";
import { UserDB, VolunteerDB } from "../common/databaseModels.js";
import { Role } from "../common/interfaces.js";
import { AuthenticatedRequest } from "../common/types.js";
import connectionPool from "../config/database.js";
import { userModel, volunteerModel } from "../config/models.js";

// Load environment variables
dotenv.config();

// Define environment variables
const HOST = process.env.HOST;
const TOKEN_SECRET = process.env.TOKEN_SECRET;
const FRONTEND_HOST = process.env.FRONTEND_HOST;

//Mail Config
const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
        user: process.env.GMAIL_ID,
        pass: process.env.GMAIL_PASSWORD,
    },
});


async function checkAuthorization(
    req: AuthenticatedRequest,
    res: Response
): Promise<any> {
    const user = req.user;
    
    // If the volunteer is not verified, return an error
    let volunteer;
    if (user && user.role === Role.volunteer) {
        volunteer = await volunteerModel.getVolunteerByUserId(user.user_id);
        
        if (!volunteer.active) {
            return res.status(401).json({
                error: "Unauthorized",
            });
        }
    }

    return res.status(200).json({
        user: {
            ...user,
            volunteer: volunteer,
        },
    });
}

async function registerUser(
    req: Request, 
    res: Response
): Promise<any> {
    // Get the user details from the request body
    let { firstName, lastName, email, password, role } = req.body;

    // Trim the user details
    firstName = firstName.trim();
    lastName = lastName.trim();
    email = email.trim();
    role = role.trim();

    // Hash Password with salt
    const digest = bcrypt.hashSync(password, 10);

    // User Id
    const user_id = uuidv4();

    const transaction = await connectionPool.getConnection();
    try {
        // Create User
        await userModel.insertUser({
            user_id: user_id,
            f_name: firstName,
            l_name: lastName,
            email: email,
            password: digest,
            role: role,
        } as UserDB, transaction);

        switch (role) {
            case Role.volunteer:
                await volunteerModel.insertVolunteer({
                    volunteer_id: uuidv4(),
                    fk_user_id: user_id,
                    active: false,
                } as VolunteerDB, transaction);
        
                // Send a confirmation email
                const mailOptions = {
                    from: '"Team Neuron" <neuronbc@gmail.com>',
                    to: email,
                    subject: "Neuron - Account Created",
                    html: `Hello ${firstName} ${lastName},<br><br>
                            Your Neuron account has been created successfully.<br>
                            Please wait for the team to verify your account. This usually takes around 3-4 hours.<br><br>
                            Thank you!<br>
                            Best,<br>
                            Team Neuron`,
                };
        
                // Send the mail, ignore errors, not an important email
                await transporter.sendMail(mailOptions).catch();
                break;

            default: // Cant create admin/instructor currently
                return res.status(401).json({
                    error: "Unauthorized",
                });
        }

        transaction.commit();

        return res.status(200).json({
            message: "User created successfully",
        });
    } catch (error) {
        // Rollback
        await transaction.rollback();
        throw error;
    }
}

async function loginUser(req: Request, res: Response): Promise<any> {
    // Get the user details from the request body
    let { email, password } = req.body;

    // Trim the user details
    email = email.trim();
    password = password.trim();

    // Get the user from the database
    const user = await userModel.getUserByEmail(email, true);

    // If the password is incorrect, return an error
    if (!bcrypt.compareSync(password, user.password)) {
        return res.status(403).json({
            error: "Incorrect password",
        });
    }

    // If the volunteer is not verified, return an error
    if (user.role === Role.volunteer) {
        const volunteer = await volunteerModel.getVolunteerByUserId(user.user_id);

        if (!volunteer.active) {
            return res.status(403).json({
                error: "Waiting for an admin to verify your account.\nYou can reach out to us at bwp@gmail.com",
            });
        }
    }

    // If the TOKEN_SECRET is not defined, return an error
    if (!TOKEN_SECRET) {
        return res.status(500);
    }

    const secret = TOKEN_SECRET;
    const payload = {
        user_id: user.user_id,
    };

    // Create a token that expires in 24 hours
    const token = jwt.sign(payload, secret, { expiresIn: "24h" });

    return res.status(200).json({
        token: token,
    });
}

async function sendResetPasswordEmail(
    req: Request,
    res: Response
): Promise<any> {
    // Get the email from the request body
    let { email } = req.body;

    const user = await userModel.getUserByEmail(email, true);
    const volunteer = await volunteerModel.getVolunteerByUserId(user.user_id);

    if (!TOKEN_SECRET) {
        return res.status(500).json({
            error: "Server configuration error: TOKEN_SECRET is not defined",
        });
    }

    // Generate a secret for the token
    const secret = TOKEN_SECRET + user.password;
    const payload = {
        user_id: user.user_id,
    };

    // Create a token that expires in 24 hours
    const token = jwt.sign(payload, secret, { expiresIn: "2h" });

    if (!HOST) {
        return res.status(500).json({
            error: "Server configuration error: HOST is not defined",
        });
    }

    const forgotPasswordLink = `${HOST}/auth/forgot-password/${user.user_id}/${token}`;

    const mailOptions = {
        from: '"Team Neuron" <neuronbc@gmail.com>',
        to: email,
        subject: "Neuron - Reset Password",
        html: `Hello ${volunteer.p_name || volunteer.f_name} ${volunteer.l_name},<br><br>
            Please use the following link to reset your account's password:<br>
            <a href="${forgotPasswordLink}">${forgotPasswordLink}</a><br><br>
            Please note that this link will expire in 2 hours.<br><br>
            Thank you!<br>
            Best,<br>
            Team Neuron`,
    };

    // Send the mail
    await transporter.sendMail(mailOptions);

    return res.status(200).json({
        message: `Mail sent successfully`,
    });
}

async function verifyUserWithIdAndToken(
    id: string,
    token: string
): Promise<any> {
    const user = await userModel.getUserById(id, true);

    if (!TOKEN_SECRET || !FRONTEND_HOST) {
        throw {
            status: 500
        };
    }

    // Verify if token is valid
    const secret = TOKEN_SECRET + user.password;

    // Throw if verify fails
    try {   
        jwt.verify(token, secret);
    } catch {
        throw {
            status: 401,
            message: "Unauthorized"
        }
    }

    return "Verified";
}

async function verifyAndRedirect(
    req: Request, 
    res: Response
): Promise<any> {
    const { id, token } = req.params;

    await verifyUserWithIdAndToken(id, token);

    return res.redirect(
        `${FRONTEND_HOST}/auth/reset-password?id=${id}&token=${token}`
    );
}

async function resetPassword(req: Request, res: Response): Promise<any> {
    // Get the id, token, and password from the request body
    const { password, id, token } = req.body;

    // Verify if the id and token are valid
    await verifyUserWithIdAndToken(id, token);

    // Hash the new password
    const hashedPassword = bcrypt.hashSync(password, 10);

    await userModel.updateUserPassword(id, hashedPassword);

    return res.status(200).json({
        message: "Password updated successfully",
    });
}

async function updatePassword(
    req: AuthenticatedRequest,
    res: Response
): Promise<any> {
    // Get the current and new password from the request
    const { currentPassword, newPassword } = req.body;

    // User coming from the isAuthorized middleware, query auth info
    const user = req.user;
    const authInfo = await userModel.getUserByEmail(user.email, true);

    // If the password is incorrect, return an error
    if (!bcrypt.compareSync(currentPassword, authInfo.password)) {
        return res.status(403).json({
            error: "Incorrect password",
        });
    }

    // Hash the new password and update
    const hashedPassword = bcrypt.hashSync(newPassword, 10);
    await userModel.updateUserPassword(user.user_id, hashedPassword);

    return res.status(200).json({
        message: "Password updated successfully",
    });
}

export {
    checkAuthorization, loginUser, registerUser, resetPassword, sendResetPasswordEmail,
    updatePassword, verifyAndRedirect
};

================
File: src/controllers/availabilityController.ts
================
import { Response } from 'express';
import { AvailabilityDB } from '../common/databaseModels.js';
import { AuthenticatedRequest } from '../common/types.js';
import { availabilityModel } from '../config/models.js';

async function getAvailabilities(req: AuthenticatedRequest, res: Response) {
    const availabilities = await availabilityModel.getAvailabilities();

    res.status(200).json(availabilities);
}

async function getAvailabilityByVolunteerId(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;

    const availability = await availabilityModel.getAvailabilityByVolunteerId(volunteer_id);
    
    res.status(200).json(availability);
}

async function setAvailabilityByVolunteerId(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;
    const availabilities: AvailabilityDB[] = req.body;

    const result = await availabilityModel.setAvailabilityByVolunteerId(volunteer_id, availabilities);

    res.status(200).json(result);
}

async function updateAvailabilityByVolunteerId(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;
    const availabilities: AvailabilityDB[] = req.body;

    const result = await availabilityModel.updateAvailabilityByVolunteerId(volunteer_id, availabilities);

    res.status(200).json(result);
}

export {
    getAvailabilities,
    getAvailabilityByVolunteerId,
    setAvailabilityByVolunteerId,
    updateAvailabilityByVolunteerId
};

================
File: src/controllers/classController.ts
================
import { Response } from 'express';
import { ClassDB } from '../common/databaseModels.js';
import { AuthenticatedRequest } from '../common/types.js';
import { classesModel } from '../config/models.js';

async function getAllClasses(req: AuthenticatedRequest, res: Response) {
	const classes = await classesModel.getClasses();

	res.status(200).json(classes);
}

async function addClass(req: AuthenticatedRequest, res: Response) {
	const newClass: ClassDB = req.body;
	const schedules = req.body.schedules;

	const result = await classesModel.addClass(newClass, schedules);

	res.status(200).json(result);
}

async function updateClass(req: AuthenticatedRequest, res: Response) {
	const class_id = Number(req.params.class_id);
	const partialClass: Partial<ClassDB> = req.body;

	const result = await classesModel.updateClass(class_id, partialClass);
	
	return res.status(200).json(result);
}

async function deleteClass(req: AuthenticatedRequest, res: Response) {
	const class_id = Number(req.params.class_id);

	const result = await classesModel.deleteClass(class_id);

	return res.status(200).json(result);
}

async function getClassesByDay(req: AuthenticatedRequest, res: Response) {
	const { day } = req.params;

	const classes = await classesModel.getClassesByDay(day);

	res.status(200).json(classes);
}

// get class info for a specific shift ID
async function getClassById(req: AuthenticatedRequest, res: Response) {
	const class_id = Number(req.params.class_id);

	const class_info = await classesModel.getClassById(class_id);

	res.status(200).json(class_info);
}

async function uploadClassImage(req: AuthenticatedRequest, res: Response) {
	const class_id = Number(req.params.class_id);
	const image = req.file!.buffer;

	const imageId = await classesModel.upsertClassImage(class_id, image);

	return res.status(201).json({
		message: 'Image uploaded successfully',
		data: imageId
	});
}

export {
	addClass, deleteClass, getAllClasses, getClassById,
	getClassesByDay, updateClass, uploadClassImage
};

================
File: src/controllers/imageController.ts
================
import { Response } from "express";
import { AuthenticatedRequest } from "../common/types.js";
import { imageModel } from "../config/models.js";

export async function getImage(req: AuthenticatedRequest, res: Response) {
    const { image_id } = req.params;

    const image = await imageModel.getImage(image_id);
    
    res.type('image/png').send(image.image);
}

================
File: src/controllers/instructorController.ts
================
import { Response } from 'express';
import { InstructorDB } from '../common/databaseModels.js';
import { AuthenticatedRequest } from '../common/types.js';
import { instructorModel } from '../config/models.js';

async function getInstructors(req: AuthenticatedRequest, res: Response) {
    const instructors = await instructorModel.getInstructors();

    res.status(200).json(instructors);
}

async function getInstructorById(req: AuthenticatedRequest, res: Response) {
    const { instructor_id } = req.params;

    const instructor = await instructorModel.getInstructorById(instructor_id);
    
    res.status(200).json(instructor);
}

async function insertInstructor(req: AuthenticatedRequest, res: Response) {
    const instructor: InstructorDB = req.body;

    const result = await instructorModel.insertInstructor(instructor);

    res.status(200).json(result);
}

export {
    getInstructorById, getInstructors, insertInstructor
};

================
File: src/controllers/scheduleController.ts
================
import { Response } from 'express';
import { ScheduleDB } from '../common/databaseModels.js';
import { AuthenticatedRequest } from '../common/types.js';
import { scheduleModel } from '../config/models.js';

async function getAllSchedules(req: AuthenticatedRequest, res: Response) {
    const schedules = await scheduleModel.getAllSchedules();
    
    res.status(200).json(schedules);
}

async function getActiveSchedulesForClass(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);

    const schedules = await scheduleModel.getActiveSchedulesForClass(class_id);

    res.status(200).json(schedules);
}

async function addSchedulesToClass(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);
    const schedules: ScheduleDB[] = req.body;

    const result = await scheduleModel.addSchedulesToClass(class_id, schedules);

    res.status(200).json(result);
}

async function deleteOrSoftDeleteSchedules(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);
    const { schedule_ids } = req.body;

    const result = await scheduleModel.deleteOrSoftDeleteSchedules(class_id, schedule_ids);

    res.status(200).json(result);
}

async function deleteSchedulesFromClass(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);
    const { schedule_ids } = req.body;

    const result = await scheduleModel.deleteSchedulesFromClass(class_id, schedule_ids);

    res.status(200).json(result);
}

async function assignVolunteersToSchedule(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);
    const schedule_id = Number(req.params.schedule_id);
    const { volunteer_ids } = req.body;

    const result = await scheduleModel.assignVolunteersByScheduleId(class_id, schedule_id, volunteer_ids);

    res.status(200).json(result);
}

async function updateSchedulesForClass(req: AuthenticatedRequest, res: Response) {
    const class_id = Number(req.params.class_id);
    const schedules: ScheduleDB[] = req.body;

    const result = await scheduleModel.updateSchedulesForClass(class_id, schedules);

    res.status(200).json(result);
}

export {
    addSchedulesToClass,
    assignVolunteersToSchedule, deleteOrSoftDeleteSchedules,
    deleteSchedulesFromClass, getActiveSchedulesForClass, getAllSchedules, updateSchedulesForClass
};

================
File: src/controllers/shiftController.ts
================
import { Response } from 'express';
import { ShiftDB } from '../common/databaseModels.js';
import { AuthenticatedRequest } from '../common/types.js';
import { shiftModel } from '../config/models.js';

async function getShift(req: AuthenticatedRequest, res: Response){
    const { shift_id } = req.body;

    const shift_info = await shiftModel.getShiftInfo(shift_id);

    res.status(200).json(shift_info);
}

// get all the shifts assigned to a volunteer, using the volunteer's ID
async function getShifts(req: AuthenticatedRequest, res: Response) {
    const { volunteer, before, after, type } = req.query as Record<string, string>;
    const volunteer_id = volunteer;

    // if (req!.user.role === 'volunteer') {
    //     const volunteer = await volunteerModel.getVolunteerByUserId(req.user.user_id);

    //     /* Cannot get shifts for other volunteer */
    //     if (volunteer.volunteer_id !== volunteer_id) {
    //         return res.status(403).json({
    //             error: "Unauthorized",
    //         });
    //     }
    // }

    const shifts = await shiftModel.getShifts({
        volunteer_id: volunteer_id,
        before: new Date(before), 
        after: new Date(after), 
        type: type as any
    });

    res.status(200).json(shifts);
}

// get all the shifts viewable for a volunteer for the month around a given date
async function getShiftsByVolunteerIdAndMonth(req: AuthenticatedRequest, res: Response) {
    const shift: ShiftDB = req.body;

    const date = new Date(shift.shift_date + 'T00:00:00'); // Adding time to avoid timezone issues
    const month: number = date.getMonth() + 1;
    const year: number = date.getFullYear();

    const shifts = await shiftModel.getShiftsByVolunteerIdAndMonth(shift.fk_volunteer_id, month, year);

    res.status(200).json(shifts);
}

async function addShift(req: AuthenticatedRequest, res: Response) {
    const shift: ShiftDB = req.body;

    const request = await shiftModel.addShift(shift);
    const addedShift = {
        shift_id: request.insertId,
        fk_volunteer_id: shift.fk_volunteer_id ?? null,
        fk_schedule_id: shift.fk_schedule_id,
        shift_date: shift.shift_date,
        duration: shift.duration,
        checked_in: shift.checked_in
    };

    res.status(200).json(addedShift);
}

async function deleteShift(req: AuthenticatedRequest, res: Response) {
    const shift_id = Number(req.params.shift_id);

    const request = await shiftModel.deleteShift(shift_id);

    res.status(200).json(request);
}

async function updateShift(req: AuthenticatedRequest, res: Response) {
    const shift_id = Number(req.params.shift_id);
    const shift: ShiftDB = req.body;

    const request = await shiftModel.updateShift(shift_id, shift);

    res.status(200).json(request);
}

// volunteer checks into a shift
async function checkInShift(req: AuthenticatedRequest, res: Response) {
    const shift_id = Number(req.params.shift_id);

    const request = await shiftModel.updateShiftCheckIn(shift_id);

    res.status(200).json(request);
}

// volunteer requesting to cover someone elseâ€™s open shift
async function requestCoverShift(req: AuthenticatedRequest, res: Response) {
    const { request_id, volunteer_id } = req.body;

    const request = await shiftModel.insertCoverShift(request_id, volunteer_id);

    res.status(200).json(request);
}

// volunteer cancels on covering a shift
async function withdrawCoverShift(req: AuthenticatedRequest, res: Response) {
    const { request_id, volunteer_id } = req.body;

    const request = await shiftModel.deleteCoverShift(request_id, volunteer_id);

    res.status(200).json(request);
}

// volunteer requests coverage for their own shift
async function requestShiftCoverage(req: AuthenticatedRequest, res: Response) {
    const { shift_id } = req.body; 

    const request = await shiftModel.insertShiftCoverageRequest(shift_id);

    res.status(200).json(request);
}

// volunteers cancels their request for shift coverage
async function withdrawShiftCoverage(req: AuthenticatedRequest, res: Response) {
    const { request_id, shift_id } = req.body;

    const request = await shiftModel.deleteShiftCoverageRequest(request_id, shift_id);

    res.status(200).json(request);
}

export {
    addShift, checkInShift, deleteShift, getShift, getShifts, getShiftsByVolunteerIdAndMonth, requestCoverShift, requestShiftCoverage, updateShift, withdrawCoverShift, withdrawShiftCoverage
};

================
File: src/controllers/userController.ts
================
import { Response } from "express";
import { AuthenticatedRequest } from "../common/types.js";
import { userModel } from "../config/models.js";

async function getUserById(req: AuthenticatedRequest, res: Response) {
    const { user_id } = req.params;

    const user = await userModel.getUserById(user_id);
    
    res.status(200).json(user);
}

async function insertProfilePicture(req: AuthenticatedRequest, res: Response) {
    const { user_id } = req.params;
    const image = req.file!.buffer;

    const imageId = await userModel.upsertUserProfileImage(user_id, image);

    return res.status(201).json(imageId);
}

export {
    getUserById, insertProfilePicture
};

================
File: src/controllers/volunteerController.ts
================
import { Response } from "express";
import { AuthenticatedRequest } from "../common/types.js";
import { volunteerModel } from "../config/models.js";

async function getVolunteerById(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;

    const volunteers = await volunteerModel.getVolunteersByIds(volunteer_id);

    if (volunteers.length === 0) {
        throw {
            status: 400,
            message: `No volunteer found under the given ID`,
        };
    }

    res.status(200).json(volunteers[0]);
}

async function getVolunteers(req: AuthenticatedRequest, res: Response) {
    const volunteers = await volunteerModel.getAllVolunteers();

    res.status(200).json(volunteers);
}

// Update a volunteer's profile based on the volunteer_id
async function updateVolunteer(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;
    const volunteerData = req.body;

    const updatedVolunteer = await volunteerModel.updateVolunteer(
        volunteer_id,
        volunteerData
    );

    res.status(200).json(updatedVolunteer);
}

// Update a volunteer's profile based on the volunteer_id
async function shiftCheckIn(req: AuthenticatedRequest, res: Response) {
    const { volunteerID, scheduleID, shiftDate } = req.body;

    const updatedVolunteer = await volunteerModel.shiftCheckIn(volunteerID, scheduleID, shiftDate);
    
    res.status(200).json(updatedVolunteer);
}

async function getPreferredClassesById(req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;

    if (!volunteer_id) {
        return res.status(400).json({
            error: "Missing required parameter: 'volunteer_id'",
        });
    }

    try {
        const preferred_classes = await volunteerModel.getPreferredClassesById(volunteer_id);

        res.status(200).json(preferred_classes);
    } catch (error: any) {
        return res.status(error.status ?? 500).json({
			error: error.message
		});
    }
}

async function getAllClassPreferences(req: AuthenticatedRequest, res: Response) {
    try {
        const all_preferred_classes = await volunteerModel.getAllClassPreferences();
        res.status(200).json(all_preferred_classes);
    } catch (error: any) {
        return res.status(error.status ?? 500).json({
			error: error.message
		});
    }
}

async function updatePreferredClassesById (req: AuthenticatedRequest, res: Response) {
    const { volunteer_id } = req.params;
    const data = req.body;

    if (!volunteer_id) {
        return res.status(400).json({
            error: "Missing required parameter: 'volunteer_id'",
        });
    } else if (!data) {
        return res.status(400).json({
            error: "Missing required body for class preferences: 'data'",
        });
    }

    try {
        await volunteerModel.updatePreferredClassesById(volunteer_id, data);

        res.status(200).json({msg: "Successfully updated class preferences"});
    } catch (error: any) {
        return res.status(error.status ?? 500).json({
			error: error.message
		});
    }
}

export {
    getAllClassPreferences, getPreferredClassesById, getVolunteerById,
    getVolunteers,
    shiftCheckIn, updatePreferredClassesById, updateVolunteer
};

================
File: src/models/availabilityModel.ts
================
import { PoolConnection, ResultSetHeader } from "mysql2/promise";
import { AvailabilityDB } from "../common/databaseModels.js";
import connectionPool from "../config/database.js";

export default class AvailabilityModel {
  async getAvailabilities(): Promise<AvailabilityDB[]> {
    const query = "SELECT * FROM availability";

    const [results, _] = await connectionPool.query<AvailabilityDB[]>(query, []);
    return results;
  }

  async getAvailabilityByVolunteerId(volunteer_id: string): Promise<AvailabilityDB[]> {
    const query = "SELECT * FROM availability WHERE fk_volunteer_id = ?";
    const values = [volunteer_id];

    const [results, _] = await connectionPool.query<AvailabilityDB[]>(query, values);
    return results;
  }

  async setAvailabilityByVolunteerId(volunteer_id: string, availabilities: AvailabilityDB[], transaction?: PoolConnection): Promise<ResultSetHeader> {
    const connection = transaction ?? connectionPool;

    const valuesCaluse = availabilities
            .map(() => '(?)')
            .join(", ");
    const query = `INSERT INTO availability (fk_volunteer_id, day, start_time, end_time) VALUES ${valuesCaluse}`;
    const values = availabilities.map((availability) => [
      volunteer_id,
      availability.day,
      availability.start_time,
      availability.end_time,
    ]);

    const [results, _] = await connection.query<ResultSetHeader>(query, values);
    return results;
  }

  async deleteAvailabilitiesByAvailabilityId(volunteer_id: string, availabilityIds: number[], transaction?: PoolConnection): Promise<ResultSetHeader> {
    const connection = transaction ?? connectionPool;

    const query = `DELETE FROM availability WHERE fk_volunteer_id = ? AND availability_id IN (?)`;
    const values = [volunteer_id, availabilityIds];

    const [results, _] = await connection.query<ResultSetHeader>(query, values);
    return results;
  }

  async updateAvailabilityByVolunteerId(volunteer_id: string, newAvailabilities: AvailabilityDB[]): Promise<void> {
    const transaction = await connectionPool.getConnection();

    try {
      await transaction.beginTransaction();

      // Get exisitng availabilities and conform them to our Availability type
      const existingAvailabilities = (await this.getAvailabilityByVolunteerId(volunteer_id))
        .map((availability: AvailabilityDB) => ({
          day: availability.day,
          start_time: availability.start_time.slice(0, 5),
          end_time: availability.end_time.slice(0, 5),
          availability_id: availability.availability_id,
          fk_volunteer_id: availability.fk_volunteer_id
        } as AvailabilityDB));

      const availabilityIdsToDelete: Set<number> = new Set();
      const availabilitiesToSkip: Set<AvailabilityDB> = new Set();

      // Helper function to check if two availabilities are an exact match
      const isExactMatch = (a: AvailabilityDB, b: AvailabilityDB) => (
        a.day === b.day &&
        a.start_time === b.start_time &&
        a.end_time === b.end_time
      );

      existingAvailabilities.forEach((existing: AvailabilityDB) => {
        const matchingNewAvailability = newAvailabilities.find((newAvailability: AvailabilityDB) => isExactMatch(existing, newAvailability));

        // No new availability matches the existing availability -> Mark existing availability for deletion
        if (!matchingNewAvailability) {
          if (existing.availability_id) {
            availabilityIdsToDelete.add(existing.availability_id);
          }

          // Some new availability matches the existing availability -> We don't need to add the new availability
        } else {
          availabilitiesToSkip.add(matchingNewAvailability)
        }
      });

      // Filter out availabilities that we don't need to add
      const newAvailabilitiesToAdd = newAvailabilities.filter((newAvailability: AvailabilityDB) => !availabilitiesToSkip.has(newAvailability));

      if (availabilityIdsToDelete.size > 0) {
        await this.deleteAvailabilitiesByAvailabilityId(volunteer_id, [...availabilityIdsToDelete], transaction);
      }

      if (newAvailabilitiesToAdd.length > 0) {
        await this.setAvailabilityByVolunteerId(volunteer_id, newAvailabilitiesToAdd, transaction);
      }

      await transaction.commit();
    } catch (error) {
        // Rollback
        await transaction.rollback();
        throw error;
    }
  }
}

================
File: src/models/classModel.ts
================
import { PoolConnection, ResultSetHeader } from 'mysql2/promise';
import sharp from 'sharp';
import { ClassDB, ScheduleDB } from '../common/databaseModels.js';
import connectionPool from '../config/database.js';
import ImageModel from './imageModel.js';
import ScheduleModel from './scheduleModel.js';

const imageModel = new ImageModel();
const scheduleModel = new ScheduleModel();

export default class ClassesModel {
     async getClasses(): Promise<ClassDB[]> {
          const query = `SELECT * FROM class`;

          const [results, _] = await connectionPool.query<ClassDB[]>(query, []);
          return results;
     }

     async getClassesByDay(day: string): Promise<ClassDB[]> {
          const query =`
          SELECT * FROM class 
               INNER JOIN schedule ON class.class_id = schedule.fk_class_id 
          WHERE 
               ? BETWEEN CAST(start_date as date) AND CAST(end_date as date) 
               AND schedule.active = true
               AND WEEKDAY(?) = day`;
          const values = [day, day];

          const [results, _] = await connectionPool.query<ClassDB[]>(query, values);
          return results;
     }

     async getClassById(class_id: number): Promise<any> {
          const query = `  
               SELECT 
                    c.*, 
                    i.l_name AS instructor_l_name,
                    i.f_name AS instructor_f_name,
                    i.email AS instructor_email
               FROM class c
               LEFT JOIN instructors i ON c.fk_instructor_id = i.instructor_id
               WHERE c.class_id = ? ;`;
          const values = [class_id];

          const [results, _] = await connectionPool.query<ClassDB[]>(query, values);
          if (results.length === 0) {
               throw {
                    status: 400,
                    message: `No class found under the given ID: ${class_id}`,
               };
          }

          const result = results[0];
          const schedules = await scheduleModel.getActiveSchedulesForClass(class_id);

          return {
               ...result,
               schedules: schedules
          };
     }

     async addClass(newClass: ClassDB, schedules?: ScheduleDB[]): Promise<any> {
          const transaction = await connectionPool.getConnection();

          try {
               await transaction.beginTransaction();

               const query = `INSERT INTO class 
                         (fk_instructor_id, class_name, instructions, zoom_link, start_date, end_date, category, subcategory)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;

               const { fk_instructor_id, class_name, instructions, zoom_link, start_date, end_date, category, subcategory } = newClass;
               const values = [fk_instructor_id, class_name, instructions, zoom_link, start_date, end_date, category, subcategory];

               const [results, _] = await transaction.query<ResultSetHeader>(query, values);
               const classId = results.insertId;

               let results2;
               if (schedules) {
                    results2 = await scheduleModel.addSchedulesToClass(classId, schedules, transaction);
               }
               
               const finalResults = {
                    class_id: classId,
                    ...newClass,
                    schedules: results2
               };

               await transaction.commit();

               return finalResults;
          } catch (error) {
               await transaction.rollback();
               throw error;
          }
     }

     async updateClass(class_id: number, classData: Partial<ClassDB>, transaction?: PoolConnection): Promise<any> {
          const connection = transaction ?? connectionPool;

          // Construct the SET clause dynamically
          const setClause = Object.keys(classData)
               .map((key) => `${key} = ?`)
               .join(", ");
          const query = `UPDATE class SET ${setClause} WHERE class_id = ?`;
          const values = [...Object.values(classData), class_id];

          if (setClause.length > 0) {
               await connection.query<ResultSetHeader>(query, values);
          }

          return {
               class_id: class_id,
               ...classData
          };
     }

     async upsertClassImage(class_id: number, image: Buffer): Promise<string> {
          const transaction = await connectionPool.getConnection();

          // Process image
          const processedImage = await sharp(image)
               .resize({ width: 300, fit: 'outside'})
               .rotate()
               .toFormat('webp')
               .webp({ quality: 80 })
               .toBuffer();

          try {
               const query = `SELECT * FROM class WHERE class_id = ?`;
               const values = [class_id];

               const [results, _] = await transaction.query<ClassDB[]>(query, values);
               if (results.length == 0) {
                    throw {
                         status: 400,
                         message: `No class found under the given ID: ${class_id}`,
                    };
               }

               const classData = results[0];

               // Insert or update
               let imageId;
               if (classData.fk_image_id) {
                    await imageModel.updateImage(classData.fk_image_id, processedImage, transaction);
                    imageId = classData.fk_image_id;
               } else {
                    imageId = await imageModel.uploadImage(processedImage, transaction);
                    await this.updateClass(class_id, { fk_image_id: imageId } as ClassDB, transaction);
               }

               await transaction.commit();

               return imageId;
          } catch (error) {
               // Rollback
               await transaction.rollback();
               throw error;
          }
     }

     async deleteClass(class_id: number): Promise<ClassDB> {
          const transaction = await connectionPool.getConnection();
     
          try {
               const query1 = `SELECT * FROM class WHERE class_id = ?`;
               const values1 = [class_id];

               const [results, _] = await transaction.query<ClassDB[]>(query1, values1);
               if (results.length == 0) {
                    throw {
                         status: 400,
                         message: `No class found under the given ID: ${class_id}`,
                    };
               }

               const classData = results[0];
     
               // Delete profile photo before user
               if (classData.fk_image_id) {
                    await imageModel.deleteImage(classData.fk_image_id, transaction);
               }
     
               const query = `DELETE FROM class WHERE class_id = ?`;
               const values = [class_id];
     
               await transaction.query<ResultSetHeader>(query, values);
     
               await transaction.commit();

               return classData;
          } catch (error) {
               // Rollback
               await transaction.rollback();
               throw error;
          }
     }
}

================
File: src/models/imageModel.ts
================
import { PoolConnection, ResultSetHeader } from 'mysql2/promise';
import { v4 as uuidv4 } from "uuid";
import { ImageDB } from '../common/databaseModels.js';
import poolConnection from '../config/database.js';

export default class ImageModel {
     async getImage(image_id: string): Promise<ImageDB> {
          const query = `SELECT * FROM images WHERE image_id = ?`;
          const values = [image_id];

          const [results, _] = await poolConnection.query<ImageDB[]>(query, values);
     
          return results[0];
     };

     async updateImage(image_id: string, image: Buffer, transaction?: PoolConnection): Promise<ResultSetHeader> {
          const connection = transaction ?? poolConnection;

          const query = `UPDATE images SET image = ? WHERE image_id = ?`;
          const values = [image, image_id];

          const [results, _] = await connection.query<ResultSetHeader>(query, values);

          return results;
     }

     async uploadImage(image: Buffer, transaction?: PoolConnection): Promise<string> {
          const connection = transaction ?? poolConnection;

          const query = `INSERT INTO images (image_id, image) VALUES (?, ?)`;
          const uuid = uuidv4();
          const values = [uuid, image];

          await connection.query<ResultSetHeader>(query, values);
     
          return uuid;
     }

     async deleteImage(image_id: string, transaction?: PoolConnection): Promise<void> {
          const connection = transaction ?? poolConnection;

          const query = `DELETE FROM images WHERE image_id = ?`;
          const values = [image_id];

          await connection.query<ResultSetHeader>(query, values);
     }
}

================
File: src/models/instructorModel.ts
================
import { ResultSetHeader } from 'mysql2';
import { InstructorDB } from '../common/databaseModels.js';
import connectionPool from '../config/database.js';

export default class InstructorModel {
  async getInstructors(): Promise<InstructorDB[]> {
    const query = `SELECT * FROM instructors`;

    const [results, _] = await connectionPool.query<InstructorDB[]>(query, []);
     
    return results;
  }

  async getInstructorById(instructor_id: string): Promise<InstructorDB> {
    const query = "SELECT * FROM instructors WHERE instructor_id = ?";
    const values = [instructor_id];

    const [results, _] = await connectionPool.query<InstructorDB[]>(query, values);

    if (results.length === 0) {
      throw {
        status: 400,
        message: `No instructor found under the given ID: ${instructor_id}`,
      };
    }
    
    return results[0];
  };

  async insertInstructor(instructor: InstructorDB): Promise<ResultSetHeader> {
    const query = `INSERT INTO 
      instructors (instructor_id, f_name, l_name, email)
      VALUES (?, ?, ?, ?)`;

    const { instructor_id, f_name, l_name, email } = instructor;
    const values = [instructor_id, f_name, l_name, email];

    const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

    return results;
  };
}

================
File: src/models/scheduleModel.ts
================
import { ResultSetHeader } from 'mysql2';
import { PoolConnection } from 'mysql2/promise';
import { ScheduleDB, ShiftDB, VolunteerScheduleDB } from '../common/databaseModels.js';
import connectionPool from '../config/database.js';
import ShiftModel from '../models/shiftModel.js';
import VolunteerModel from './volunteerModel.js';

const shiftModel = new ShiftModel();
const volunteerModel = new VolunteerModel();

export default class ScheduleModel {
    async getAllSchedules(): Promise<ScheduleDB[]> {
        const query = `
            SELECT 
                s.*,
                GROUP_CONCAT(vs.fk_volunteer_id) as volunteer_ids
            FROM schedule s 
            LEFT JOIN volunteer_schedule vs
            ON s.schedule_id = vs.fk_schedule_id
            WHERE s.active = true
            GROUP BY s.schedule_id`;

        const [results, _] = await connectionPool.query<ScheduleDB[]>(query, []);

        return this.formatResults(results);
    }

    async getActiveSchedulesForClass(classId: number): Promise<ScheduleDB[]> {
        const query = `
            SELECT 
                s.*,
                GROUP_CONCAT(vs.fk_volunteer_id) as volunteer_ids
            FROM schedule s 
            LEFT JOIN volunteer_schedule vs
            ON s.schedule_id = vs.fk_schedule_id
            WHERE fk_class_id = ?
            AND s.active = true
            GROUP BY s.schedule_id`;
        const values = [classId];

        const [results, _] = await connectionPool.query<ScheduleDB[]>(query, values);
        
        return this.formatResults(results);
    }

    private async formatResults(schedules: ScheduleDB[]): Promise<any[]> {
        const volunteer_ids = schedules.flatMap(s => s.volunteer_ids ? s.volunteer_ids.split(',') : []);
        const volunteers = (await volunteerModel.getVolunteersByIds(volunteer_ids)).reduce((map: any, volunteer) => {
            map[volunteer.volunteer_id] = volunteer;
            return map;
        }, {});

        return schedules.map(schedule => {
            const schedule_volunteer_ids = schedule.volunteer_ids ? schedule.volunteer_ids.split(',') : []
            const schedule_volunteers = schedule_volunteer_ids.flatMap((id: string) => volunteers[id]);

            const { volunteer_ids, ...rest } = schedule;
            return {
                ...rest,
                volunteers: schedule_volunteers
            };
        });
    }

    private async addSchedulesWithTransaction(classId: number, scheduleItems: ScheduleDB[], transaction: PoolConnection): Promise<any> {
        const valuesClause1 = scheduleItems
            .map(() => '(?)')
            .join(", ");
        const query1 = `INSERT INTO schedule (fk_class_id, day, start_time, end_time) VALUES ${valuesClause1}`;
        const values1 = scheduleItems.map((schedule) => [
            classId,
            schedule.day,
            schedule.start_time,
            schedule.end_time,
        ]);
        
        const [results1, _] = await transaction.query<ResultSetHeader>(query1, values1);

        const scheduleIds: number[] = [];
        for (let scheduleId = results1.insertId; scheduleId < results1.insertId + results1.affectedRows; scheduleId++) {
            scheduleIds.push(scheduleId);
        }
        
        const createdSchedules = scheduleIds.map((schedule_id, index) => {
            const schedule = scheduleItems[index];
            return {
                schedule_id: schedule_id,
                fk_class_id: classId,
                day: schedule.day,
                start_time: schedule.start_time,
                end_time: schedule.end_time,
                volunteer_ids: schedule.volunteer_ids
            }
        });

        this.assignVolunteers(classId, createdSchedules, transaction);

        return createdSchedules;
    }

    async addSchedulesToClass(classId: number, scheduleItems: ScheduleDB[], transaction?: PoolConnection): Promise<any> {
        if (transaction) {
            return await this.addSchedulesWithTransaction(classId, scheduleItems, transaction);
        }

        transaction = await connectionPool.getConnection();
        try {
            await transaction.beginTransaction();
            const results = await this.addSchedulesWithTransaction(classId, scheduleItems, transaction);
            await transaction.commit();

            return results;
        } catch (error) {
            // Rollback
            await transaction.rollback();
            throw error;
        }
    }
  
    async deleteSchedulesFromClass(classId: number, scheduleIds: number[], transaction?: PoolConnection): Promise<any> {
        const connection = transaction ?? connectionPool;

        const query = `DELETE FROM schedule WHERE fk_class_id = ? AND schedule_id IN (?)`;
        const values = [classId, scheduleIds];

        const [results, _] = await connection.query<ResultSetHeader>(query, values);

        return results;
    }

    private async setSchedulesInactive(scheduleIds: number[], transaction: PoolConnection): Promise<void> {
        const query = `UPDATE schedule SET active = false WHERE schedule_id IN (?)`;
        const values = [scheduleIds];
        await transaction.query<ResultSetHeader>(query, values);
    }

    async deleteOrSoftDeleteSchedules(classId: number, scheduleIds: number[]): Promise<any> {
        const transaction = await connectionPool.getConnection();
        try {
            await transaction.beginTransaction();

            // make sure schedules exist
            const schedulesExist = await this.verifySchedulesExist(classId, scheduleIds, transaction);
            if (!schedulesExist) {
                throw new Error('All schedules must contain a valid schedule_id.');
            }

            // unassign current volunteers from schedule
            await this.unassignVolunteers(scheduleIds, transaction);

            // check if there are any shifts still remaining (historic shifts)
            const schedulesToSetInactive = await this.getSchedulesToSetInactive(scheduleIds, transaction);

            // get schedules to delete completely
            const schedulesToDelete = await this.getSchedulesToDelete(schedulesToSetInactive, scheduleIds, transaction);

            // set these schedules as inactive
            if (schedulesToSetInactive.length > 0) {
                await this.setSchedulesInactive(schedulesToSetInactive, transaction);
            }

            // delete these schedules
            if (schedulesToDelete.length > 0) {
                await this.deleteSchedulesFromClass(classId, schedulesToDelete, transaction);
            }

            await transaction.commit();

            return {
                inactiveSchedules: schedulesToSetInactive,
                deletedSchedules: schedulesToDelete
            }
        } catch (error) {
            await transaction.rollback();
            throw error;
        }
    }

    private async getSchedulesToDelete(schedulesToSetInactive: number[], scheduleIds: number[], transaction: PoolConnection) {
        const query = `
                SELECT schedule_id
                FROM schedule
                WHERE schedule_id IN (?) 
                ${schedulesToSetInactive.length > 0 ? "AND schedule_id NOT IN (?)" : ""}
            `;
        const values = [scheduleIds, schedulesToSetInactive];
        const [results, _] = await transaction.query<ScheduleDB[]>(query, values);
        const schedulesToDelete = results.map((result) => result.schedule_id as number);
        return schedulesToDelete;
    }

    private async getSchedulesToSetInactive(scheduleIds: number[], transaction: PoolConnection) {
        const query = `
                SELECT DISTINCT fk_schedule_id
                FROM shifts
                WHERE fk_schedule_id IN (?)
            `;
        const values = [scheduleIds];
        const [results, _] = await transaction.query<ShiftDB[]>(query, values);
        const schedulesToSetInactive = results.map((result) => result.fk_schedule_id);
        return schedulesToSetInactive;
    }

    async getModifiedSchedules(schedules: ScheduleDB[], transaction: PoolConnection): Promise<ScheduleDB[]> {
        const scheduleIds = schedules.map(schedule => schedule.schedule_id);
        const query = `
            SELECT
                schedule_id,
                day,
                TIME_FORMAT(start_time, '%H:%i') AS start_time,
                TIME_FORMAT(end_time, '%H:%i') AS end_time 
            FROM schedule 
            WHERE schedule_id IN (?)
        `;
        const values = [scheduleIds];
        const [results, _] = await transaction.query<ScheduleDB[]>(query, values);

        // get rid of leading zeros
        const formatTime = (time: string): string => {
            return time.replace(/^0/, '');
        }

        return schedules.filter((schedule) => {
            const scheduleInDb = results.find(result => result.schedule_id === schedule.schedule_id);
            return scheduleInDb && 
                (scheduleInDb.day != schedule.day ||
                formatTime(scheduleInDb.start_time) != formatTime(schedule.start_time) ||
                formatTime(scheduleInDb.end_time) != formatTime(schedule.end_time));
        })
    }

    async verifySchedulesExist(classId: number, scheduleIds: number[], transaction: PoolConnection): Promise<boolean> {
        const query = `SELECT * FROM schedule WHERE fk_class_id = ? AND schedule_id IN (?) AND active = true`;
        const values = [classId, scheduleIds];
        const [results, _] = await transaction.query<ScheduleDB[]>(query, values);
        return results.length === scheduleIds.length;
    }

    private async buildSchedulesWithVolunteers(schedules: ScheduleDB[], transaction: PoolConnection) {
        const schedulesWithVolunteers = schedules.filter(schedule => schedule.volunteer_ids !== undefined);
        const schedulesWithoutVolunteers = schedules.filter(schedule => schedule.volunteer_ids === undefined);

        // for schedules with no volunteers given, get current volunteers from db
        if (schedulesWithoutVolunteers.length > 0) {
            const scheduleIds = schedulesWithoutVolunteers.map(schedule => schedule.schedule_id as number);

            // get the currently assigned volunteers
            const assignments = await this.getCurrentAssignments(scheduleIds, transaction);

            schedulesWithoutVolunteers.forEach((schedule) => {
                const assignedVolunteers = assignments.get(schedule.schedule_id as number);
                schedulesWithVolunteers.push({
                    ...schedule,
                    volunteer_ids: assignedVolunteers ?? []
                });
            });
        }
        return schedulesWithVolunteers;
    }

    async updateModifiedHistoric(classId: number, schedules: ScheduleDB[], transaction: PoolConnection): Promise<any> {
        if (schedules.length === 0) {
            return {
                addedSchedules: [],
                inactiveSchedules: []
            }
        }
        const schedulesWithVolunteers = await this.buildSchedulesWithVolunteers(schedules, transaction);
        const scheduleIds = schedulesWithVolunteers.map(schedule => schedule.schedule_id as number);

        // unassign volunteers from schedules going inactive
        await this.unassignVolunteers(scheduleIds, transaction);

        // set schedules inactive
        await this.setSchedulesInactive(scheduleIds, transaction);

        // add new schedules to db with their assignments
        const addedSchedules = await this.addSchedulesToClass(classId, schedulesWithVolunteers, transaction);

        return {
            addedSchedules: addedSchedules,
            inactiveSchedules: scheduleIds
        }
    }

    async updateAssignments(classId: number, schedules: ScheduleDB[], transaction: PoolConnection): Promise<ScheduleDB[]> {
        if (schedules.length === 0) {
            return [];
        }
        const schedulesWithVolunteers = schedules.filter(schedule => schedule.volunteer_ids !== undefined);
        const scheduleIds = schedulesWithVolunteers.map(schedule => schedule.schedule_id as number);

        // unassign volunteers from schedules
        await this.unassignVolunteers(scheduleIds, transaction);

        // make new assignments to the schedules
        await this.assignVolunteers(classId, schedulesWithVolunteers, transaction);

        return schedulesWithVolunteers;
    }

    async updateHistoric(classId: number, schedules: ScheduleDB[], transaction: PoolConnection): Promise<any> {
        if (schedules.length === 0) {
            return {
                addedSchedules: [],
                updatedSchedules: [],
                inactiveSchedules: []
            }
        }
        const modifiedSchedules = await this.getModifiedSchedules(schedules, transaction);
        const unmodifiedSchedules = schedules.filter(schedule => !modifiedSchedules.includes(schedule));

        const { addedSchedules, inactiveSchedules } = await this.updateModifiedHistoric(classId, modifiedSchedules, transaction);
        const updatedSchedules = await this.updateAssignments(classId, unmodifiedSchedules, transaction);

        return {
            addedSchedules: addedSchedules,
            updatedSchedules: updatedSchedules,
            inactiveSchedules: inactiveSchedules
        }
    }

    async updateModifiedNonHistoric(classId: number, schedules: ScheduleDB[], transaction: PoolConnection): Promise<ScheduleDB[]> {
        if (schedules.length === 0) {
            return [];
        }
        const schedulesWithVolunteers = await this.buildSchedulesWithVolunteers(schedules, transaction);
        const scheduleIds = schedulesWithVolunteers.map(schedule => schedule.schedule_id as number);

        // unassign volunteers from schedules
        await this.unassignVolunteers(scheduleIds, transaction);

        // safely update the schedules
        await this.updateSchedules(schedulesWithVolunteers, transaction);

        // assign volunteers to updated schedules
        await this.assignVolunteers(classId, schedulesWithVolunteers, transaction);

        return schedulesWithVolunteers;
    }


    async updateNonHistoric(classId: number, schedules: ScheduleDB[], transaction: PoolConnection): Promise<ScheduleDB[]> {
        if (schedules.length === 0) {
            return [];
        }
        const modifiedSchedules = await this.getModifiedSchedules(schedules, transaction);
        const unmodifiedSchedules = schedules.filter(schedule => !modifiedSchedules.includes(schedule));

        const updatedSchedules1 = await this.updateModifiedNonHistoric(classId, modifiedSchedules, transaction);
        const updatedSchedules2 = await this.updateAssignments(classId, unmodifiedSchedules, transaction);

        return updatedSchedules1.concat(updatedSchedules2);
    }

    /*
    Schedules with historic shifts need to be handled differently than schedules with no historic
    shifts. For example, if a schedule with historic shifts has its day of the week changed, then 
    we can not just update that schedule's 'day' field. This is because all the shifts that have 
    already happened will then also have their dependent 'shift_date' changed, which doesn't make 
    any sense.

    To preserve historic shift schedules, we need to instead set each updated schedule as inactive and 
    create a new active schedule as the updated version.

    If a schedule does not have any shifts in the past, then we can just update its fields as normal. 
    However, we still need to make sure all the shifts under that schedule still align correctly with
    the updated schedule (since shifts have a 'shift_date' field that depends on its schedule's 'day' 
    field and a 'duration' field that depends on its schedule's 'start_time' and 'end_time').
    */
    async updateSchedulesForClass(classId: number, schedules: ScheduleDB[]): Promise<any> {
        const transaction = await connectionPool.getConnection();
        try {
            await transaction.beginTransaction();

            // verify all schedules exist in db
            const scheduleIds = schedules.map(schedule => schedule.schedule_id as number);
            const schedulesExist = await this.verifySchedulesExist(classId, scheduleIds, transaction);
            if (!schedulesExist) {
                throw new Error('All schedules must contain a valid schedule_id.');
            }

            // divide into historic and non-historic schedules
            const schedulesHistoric = await shiftModel.getSchedulesWithHistoricShifts(schedules, transaction);
            const schedulesNonHistoric = schedules.filter(schedule => !schedulesHistoric.includes(schedule));

            const result = await this.updateHistoric(classId, schedulesHistoric, transaction);
            const updatedSchedules = await this.updateNonHistoric(classId, schedulesNonHistoric, transaction);

            await transaction.commit();

            return {
                addedSchedules: result.addedSchedules,
                updatedSchedules: result.updatedSchedules.concat(updatedSchedules),
                inactiveSchedules: result.inactiveSchedules
            };
        } catch (error) {
            // Rollback
            await transaction.rollback();
            throw error;
        }
    }

    async getCurrentAssignments(scheduleIds: number[], transaction: PoolConnection): Promise<Map<number, string[]>> {
        const query = `SELECT * FROM volunteer_schedule WHERE fk_schedule_id IN (?)`;
        const values = [scheduleIds];
        const [results, _] = await transaction.query<VolunteerScheduleDB[]>(query, values);
        
        const assignments: Map<number, string[]> = new Map();
        results.forEach((result: VolunteerScheduleDB) => {
            const volunteerIds = assignments.get(result.fk_schedule_id) ?? [];
            volunteerIds.push(result.fk_volunteer_id);
            assignments.set(result.fk_schedule_id, volunteerIds); 
        });
        return assignments;
    }

    async assignVolunteersByScheduleId(classId: number, scheduleId: number, volunteerIds: any[]): Promise<any> {
        const transaction = await connectionPool.getConnection();
        try {
            await transaction.beginTransaction();

            let valuesClause = "";
            const values: any[][] = [];
            volunteerIds.forEach((volunteerId) => {
                valuesClause = valuesClause.concat("(?),");
                values.push([volunteerId, scheduleId]);
            });
            valuesClause = valuesClause.slice(0, -1);

            // assign volunteers to schedule
            const query = `INSERT INTO volunteer_schedule (fk_volunteer_id, fk_schedule_id) VALUES ${valuesClause}`;
            await transaction.query<ResultSetHeader>(query, values);

            // get schedule object
            const query2 = `
                SELECT 
                    schedule_id,
                    day,
                    TIME_FORMAT(start_time, '%H:%i') AS start_time,
                    TIME_FORMAT(end_time, '%H:%i') AS end_time
                FROM schedule 
                WHERE schedule_id = ?
            `;
            const values2 = [scheduleId];
            const [result, _] = await transaction.query<ScheduleDB[]>(query2, values2);

            const schedule = {
                volunteer_ids: volunteerIds,
                ...result[0]
            }

            // create shifts for all assigned volunteers
            await shiftModel.addShiftsForSchedules(classId, [schedule], transaction);

            await transaction.commit();

            return result;
        } catch (error) {
            await transaction.rollback();
            throw error;
        }
    }

    private async assignVolunteers(classId: number, schedules: any[], transaction: PoolConnection): Promise<void> {
        let valuesClause = "";
        const values: any[][] = [];
        schedules.forEach((schedule) => {
            schedule.volunteer_ids.forEach((volunteerId: any) => {
                valuesClause = valuesClause.concat("(?),");
                values.push([volunteerId, schedule.schedule_id]);
            })
        });
        valuesClause = valuesClause.slice(0, -1);

        // if there are any volunteer assignments
        if (valuesClause.length > 0) {
            // assign volunteers to schedule
            const query = `INSERT INTO volunteer_schedule (fk_volunteer_id, fk_schedule_id) VALUES ${valuesClause}`;
            await transaction.query<ResultSetHeader>(query, values);

            // create shifts for all schedules with assigned volunteers
            await shiftModel.addShiftsForSchedules(classId, schedules, transaction);
        }
    }

    private async unassignVolunteers(scheduleIds: number[], transaction: PoolConnection): Promise<void> {
        const query = `DELETE FROM volunteer_schedule WHERE fk_schedule_id IN (?)`;
        const values = [scheduleIds];
        await transaction.query<ResultSetHeader>(query, values);

        // delete all future shifts for the schedules going inactive
        await shiftModel.deleteFutureShifts(scheduleIds, transaction);
    }

    private async updateSchedules(schedules: any[], transaction: PoolConnection): Promise<void> {
        let dayCase = '';
        let startTimeCase = '';
        let endTimeCase = '';
        const scheduleIds: any[] = [];

        // build the CASE statements for each field and collect the schedule_ids
        schedules.forEach(schedule => {
            scheduleIds.push(schedule.schedule_id);
            dayCase += `WHEN schedule_id = ${schedule.schedule_id} THEN ${schedule.day} `;
            startTimeCase += `WHEN schedule_id = ${schedule.schedule_id} THEN '${schedule.start_time}' `;
            endTimeCase += `WHEN schedule_id = ${schedule.schedule_id} THEN '${schedule.end_time}' `;
        });

        const query = `
            UPDATE schedule 
            SET 
                day = CASE 
                    ${dayCase}
                    ELSE day END, 
                start_time = CASE
                    ${startTimeCase}
                    ELSE start_time END, 
                end_time = CASE
                    ${endTimeCase}
                    ELSE end_time END
            WHERE schedule_id IN (?)
        `;
        const values = [scheduleIds];
        await transaction.query<ResultSetHeader>(query, values);
    }
}

================
File: src/models/shiftModel.ts
================
import { PoolConnection, ResultSetHeader } from 'mysql2/promise';
import { ScheduleDB, ShiftDB } from '../common/databaseModels.js';
import connectionPool from '../config/database.js';
import queryBuilder from '../config/queryBuilder.js';

export default class ShiftModel {

     // get all the details of a shift
     async getShiftInfo(shift_id: number): Promise<ShiftDB> {
          const query = `
               SELECT 
                    s.duration,
                    sc.start_time,
                    sc.end_time,
                    u.l_name AS volunteer_l_name,
                    u.f_name AS volunteer_f_name,
                    i.l_name AS instructor_l_name,
                    i.f_name AS instructor_f_name, 
                    cl.class_name
               FROM 
                    neuron.shifts s
               JOIN 
                    neuron.schedule sc ON s.fk_schedule_id = sc.schedule_id
               JOIN 
                    neuron.volunteers v ON s.fk_volunteer_id = v.volunteer_id
               JOIN 
                    neuron.users u ON u.user_id = v.fk_user_id
               JOIN 
                    neuron.class cl ON sc.fk_class_id = cl.class_id
               JOIN
                    neuron.instructors i on i.instructor_id = cl.fk_instructor_id
               WHERE 
                    s.shift_id = ?       
          `;
          const values = [shift_id];

          const [results, _] = await connectionPool.query<ShiftDB[]>(query, values);

          return results[0];
     }

     /**
      * Retrieves shifts from the database with optional filtering.
      *
      * @param {string} [params.volunteer_id] - The ID of the volunteer.
      *   - When omitted or when `type` is not 'coverage', returns only shifts assigned to the volunteer.
      *   - When `type` is 'coverage', excludes shifts assigned to the volunteer (i.e., returns shifts available for coverage).
      * @param {Date} [params.before] - Upper bound for the shift date. Shifts with a shift_date less than or equal to this date are included.
      * @param {Date} [params.after] - Lower bound for the shift date. Shifts with a shift_date greater than or equal to this date are included.
      * @param {'coverage'|'requesting'} [params.type] - The type of filtering for coverage requests:
      *   - `'coverage'`: Only include shifts with an associated coverage request and exclude shifts belonging to the specified volunteer.
      *   - `'requesting'`: Only include shifts with an associated coverage request (without excluding the volunteer).
      *
      * @returns {Promise<any[]>} A promise that resolves to an array of shift records.
      *
      * @example
      * // Get all shifts assigned to volunteer '123'
      * getShifts({ volunteer_id: '123' });
      *
      * @example
      * // Get shifts available to volunteer '123' for coverage
      * getShifts({ volunteer_id: '123', type: 'coverage' });
      *
      * @example
      * // Get shifts which volunteer '123' for is requesting coverage for
      * getShifts({ volunteer_id: '123', type: 'requesting' });
      */
     async getShifts(params?: { 
          volunteer_id?: string, 
          type?: 'coverage' | 'requesting', 
          before?: Date, 
          after?: Date, 
     }): Promise<any[]> {
          let query = queryBuilder
               .select([
                    'sh.shift_id AS id',
                    'sh.shift_date AS date',
                    'sh.duration AS duration',
                    'sh.fk_volunteer_id AS volunteer_id',
                    'sc.day AS day',
                    'sc.start_time AS startTime',
                    'sc.end_time AS endTime',
                    'c.class_id AS classId',
                    'c.class_name AS className',
                    'c.instructions AS instructions',
                    'cr.covered_by',
                    'cr.request_id AS request_id',
                    queryBuilder.raw(`CASE 
                         WHEN cr.request_id IS NOT NULL AND cr.covered_by IS NOT NULL THEN 'resolved'
                         WHEN pcr.request_id IS NOT NULL THEN 'pending'
                         WHEN cr.request_id IS NOT NULL AND cr.covered_by IS NULL THEN 'open'
                         ELSE NULL
                    END AS coverage_status`)
               ])
               .from(
                    { sh: 'shifts' }
               ).join(
                    { sc: 'schedule' }, 'sh.fk_schedule_id', 'sc.schedule_id'
               ).join(
                    { c: 'classes' }, 'sc.fk_class_id', 'c.class_id'
               ).leftJoin(
                    { cr: 'shift_coverage_request' }, 'sh.shift_id', 'cr.fk_shift_id'
               ).leftJoin(
                    { pcr: 'pending_shift_coverage' }, 'cr.request_id', 'pcr.request_id'
               );

          // Filter by date
          if (params?.before) {
               query.where('sh.shift_date', '<=', params.before);
          }
          if (params?.after) {
               query.where('sh.shift_date', '>=', params.after);
          }

          // Only want coverage
          if (params?.type === 'coverage' || params?.type === 'requesting') {
               query.whereNotNull('cr.request_id');
          }

          if (params?.volunteer_id && params?.type === 'coverage') {
               // For coverage we exclude the volunteer instead, we want shifts we can cover
               query.where('sh.fk_volunteer_id', '<>', params.volunteer_id);
          }
          else if (params?.volunteer_id) {
               query.where('sh.fk_volunteer_id', params.volunteer_id);
          }

          // Order by date then time
          query.orderBy('sh.shift_date').orderBy('sc.start_time');

          // Construct query and bindings
          const { sql, bindings } = query.toSQL();
          const [results, _] = await connectionPool.query<ShiftDB[]>(sql, bindings);

          return results;
     }

     // use getShifts instead
     async getShiftsByVolunteerId(volunteer_id: string): Promise<ShiftDB[]> {
          const query = "SELECT * FROM shifts WHERE fk_volunteer_id = ?";
          const values = [volunteer_id];

          const [results, _] = await connectionPool.query<ShiftDB[]>(query, values);

          return results;
     }

     // use getShifts instead
     async getShiftsByDate(date: string): Promise<ShiftDB[]> {
          const query = "SELECT * FROM shifts WHERE shift_date = ?";
          const values = [date];

          const [results, _] = await connectionPool.query<ShiftDB[]>(query, values);

          return results;
     }

     // use getShifts instead
     async getShiftsByVolunteerIdAndMonth(volunteer_id: string, month: number, year: number): Promise<ShiftDB[]> {
          const query = `
               CALL GetShiftsByVolunteerIdAndMonth(?, ?, ?);
          `;

          const values = [volunteer_id, month, year];

          const [results, _] = await connectionPool.query<any>(query, values);

          return results[0]; // Value from procedure stored in the first value of the array
     }

     // modify a shift to indicate that a volunteer has checked in
     async updateShiftCheckIn(shift_id: number): Promise<ResultSetHeader> {
          const query = `
               UPDATE shifts SET checked_in = 1 WHERE shift_id = ?
          `;
          const values = [shift_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }

     // create a new entry in the pending_shift_coverage table
     async insertCoverShift(request_id: number, volunteer_id: string): Promise<ResultSetHeader> {
          const query = `
               INSERT INTO pending_shift_coverage (request_id, pending_volunteer)
               VALUES (?, ?)
          `;
          const values = [request_id, volunteer_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }

     // delete corresponding entry in pending_shift_coverage table
     async deleteCoverShift(request_id: number, volunteer_id: number): Promise<ResultSetHeader> {
          const query = `
               DELETE FROM pending_shift_coverage WHERE request_id = ? AND pending_volunteer = ?
          `;
          const values = [request_id, volunteer_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          // Check if it was successfully deleted or not
          if (results.affectedRows === 0) {
               throw new Error("Cover shift request not found or already approved");
          }

          return results;
     }

     // create a new entry in the shift_coverage_request table
     async insertShiftCoverageRequest(shift_id: number): Promise<ResultSetHeader> {
          const query = `
               INSERT INTO shift_coverage_request (fk_shift_id)
               VALUES (?)
          `;
          const values = [shift_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }

     // delete corresponding entry in shift_coverage_request table
     async deleteShiftCoverageRequest(request_id: number, shift_id: number): Promise<ResultSetHeader> {
          const query = `
               DELETE FROM shift_coverage_request WHERE request_id = ? AND fk_shift_id = ? AND covered_by IS NULL
          `;
          const values = [request_id, shift_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          // Check if it was successfully deleted or not
          if (results.affectedRows === 0) {
               throw new Error("Shift coverage request not found or already fulfilled");
          }

          return results;
     }

     private getRecurringDates(classTimeline: any, startTime: string, dayNumber: number): string[] {
          const result: string[] = [];

          let start = new Date(classTimeline.start_date);
          const end = new Date(classTimeline.end_date);

          const [hours, minutes] = startTime.split(':').map(Number);
          const startDateAndTime = new Date(classTimeline.start_date);
          startDateAndTime.setHours(hours, minutes);

          const now = new Date();

          // if start is earlier than right now
          if (startDateAndTime < now) {
               start = now;

               // if schedule starts today at exactly now or at an earlier time than now, we need to skip this week
               if (dayNumber === now.getDay() &&
                    startDateAndTime.getHours() <= now.getHours() &&
                    startDateAndTime.getMinutes() <= now.getMinutes()) {

                    start.setDate(start.getDate() + 7);
               }
               // NOTE: if the schedule starts today at a later time than now, all the shifts today will still be scheduled
          }

          // find the first occurrence of the given day
          while (start.getDay() !== dayNumber) {
               start.setDate(start.getDate() + 1);
          }

          // collect all occurrences of the given day until the end date
          while (start <= end) {
               result.push(start.toISOString().split('T')[0]); // store as YYYY-MM-DD
               start.setDate(start.getDate() + 7);
          }

          return result;
     }

     // convert time in HH:MM format to minutes
     private getDurationInMinutes(startTime: string, endTime: string): number {

          const timeToMinutes = (time: string): number => {
               const [hours, minutes] = time.split(':').map(Number);
               return hours * 60 + minutes;
          };
          const startTimeInMinutes = timeToMinutes(startTime);
          const endTimeInMinutes = timeToMinutes(endTime);

          return Math.round(endTimeInMinutes - startTimeInMinutes);
     }

     async addShiftsForSchedules(classId: number, createdSchedules: any[], transaction: PoolConnection): Promise<void> {

          // get class start date and end date
          const query1 = `SELECT start_date, end_date FROM class WHERE class_id = ?`;
          const values1 = [classId];
          const [results, _] = await transaction.query<ScheduleDB[]>(query1, values1);
          const classTimeline = results[0];

          // for every schedule, for every assigned volunteer, for every date in between the class's 
          // time line - we create a new shift
          let valuesClause2 = "";
          const values2: any[][] = [];
          createdSchedules.forEach(schedule => {

               if (!schedule.volunteer_ids) {
                    return;
               }

               const dates = this.getRecurringDates(classTimeline, schedule.start_time, schedule.day);
               const duration = this.getDurationInMinutes(schedule.start_time, schedule.end_time);

               schedule.volunteer_ids.forEach((volunteer_id: any) => {

                    dates.forEach(date => {
                         valuesClause2 = valuesClause2.concat("(?),");
                         values2.push([volunteer_id, schedule.schedule_id, date, duration]);
                    })
               })
          })
          valuesClause2 = valuesClause2.slice(0, -1);

          const query2 = `INSERT INTO shifts (fk_volunteer_id, fk_schedule_id, shift_date, duration) VALUES ${valuesClause2}`;
          await transaction.query<ResultSetHeader>(query2, values2);
     }

     async getSchedulesWithHistoricShifts(schedules: ScheduleDB[], transaction: PoolConnection): Promise<ScheduleDB[]> {
          const scheduleIds = schedules.map(schedule => schedule.schedule_id);
          const query = `
               SELECT DISTINCT sh.fk_schedule_id
               FROM shifts sh
               LEFT JOIN schedule sc 
               ON sh.fk_schedule_id = sc.schedule_id
               WHERE sh.fk_schedule_id IN (?)
               AND STR_TO_DATE(CONCAT(sh.shift_date, ' ', sc.start_time), '%Y-%m-%d %H:%i:%s') <= CONVERT_TZ(NOW(), 'UTC', 'America/Vancouver')
          `;
          const values = [scheduleIds];
          const [results, _] = await transaction.query<ShiftDB[]>(query, values);
          const scheduleIdsWithHistoricShifts = results.map(result => result.fk_schedule_id);
          return schedules.filter(schedule => scheduleIdsWithHistoricShifts.includes(schedule.schedule_id as number));
     }

     // delete all shifts that have not happened yet
     async deleteFutureShifts(scheduleIds: number[], transaction: PoolConnection): Promise<any> {

          const query1 = `
               SELECT shift_id 
               FROM shifts sh
               LEFT JOIN schedule sc 
               ON sh.fk_schedule_id = sc.schedule_id
               WHERE sh.fk_schedule_id IN (?)
               AND STR_TO_DATE(CONCAT(sh.shift_date, ' ', sc.start_time), '%Y-%m-%d %H:%i:%s') > CONVERT_TZ(NOW(), 'UTC', 'America/Vancouver')
          `;
          const values1 = [scheduleIds];
          const [results, _] = await transaction.query<ShiftDB[]>(query1, values1);

          const shiftIds = results.map(result => result.shift_id);

          if (shiftIds.length > 0) {
               const query2 = `DELETE FROM shifts WHERE shift_id IN (?)`;
               const values2 = [shiftIds];
               await transaction.query<ResultSetHeader>(query2, values2);
          }
     }

     // create a new shift. having fk_volunteer_id = null indicates an unassigned shift
     async addShift(shift: ShiftDB): Promise<ResultSetHeader> {
          const query = `
               INSERT INTO shifts (fk_volunteer_id, fk_schedule_id, shift_date, duration, checked_in)
               VALUES (?, ?, ?, ?, ?)
          `;
          const values = [
               shift.fk_volunteer_id,
               shift.fk_schedule_id,
               shift.shift_date,
               shift.duration,
               shift.checked_in
          ];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }

     // update a shift by id
     async updateShift(shift_id: number, shift: ShiftDB): Promise<ResultSetHeader> {

          // Construct the SET clause dynamically
          const setClause = Object.keys(shift)
               .map((key) => `${key} = ?`)
               .join(", ");
          const query = `
               UPDATE shifts SET ${setClause} WHERE shift_id = ?;
          `;
          const values = [...Object.values(shift), shift_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }

     // delete a shift by id
     async deleteShift(shift_id: number): Promise<ResultSetHeader> {
          const query = `
               DELETE FROM shifts WHERE shift_id = ?;
          `;
          const values = [shift_id];

          const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

          return results;
     }
}

================
File: src/models/userModel.ts
================
import { ResultSetHeader } from "mysql2";
import { PoolConnection } from "mysql2/promise";
import sharp from "sharp";
import { UserDB } from "../common/databaseModels.js";
import connectionPool from "../config/database.js";
import { imageModel } from "../config/models.js";

export default class UserModel {
    async getUserById(user_id: string, password: boolean = false): Promise<UserDB> {
        const query = `
        SELECT 
            ${password ? "*" : "user_id, f_name, l_name, fk_image_id, email, role, created_at"}
        FROM users
        WHERE user_id = ?`;
        const values = [user_id];

        const [results, _] = await connectionPool.query<UserDB[]>(query, values);

        if (results.length === 0) {
            throw {
                status: 400,
                message: `No user found with the given user_id`,
            };
        }

        return results[0];
    }

    async getUserByEmail(email: string, password: boolean = false): Promise<UserDB> {
        const query = `
        SELECT 
            ${password ? "*" : "user_id, f_name, l_name, fk_image_id email, role, created_at"}
        FROM users
        WHERE email = ?`;
        const values = [email];

        const [results, _] = await connectionPool.query<UserDB[]>(query, values);

        if (results.length === 0) {
            throw {
                status: 400,
                message: `No user found with the given email`,
            };
        }

        return results[0];
    }

    async insertUser(user: Partial<UserDB>, transaction?: PoolConnection): Promise<ResultSetHeader> {
        const connection = transaction ?? connectionPool;

        const query = `INSERT INTO users (user_id, f_name, l_name, email, password, role) VALUES (?, ?, ?, ?, ?, ?)`;
        const values = [user.user_id, user.f_name, user.l_name, user.email, user.password, user.role];

        const [results, _] = await connection.query<ResultSetHeader>(query, values).catch(error => {
            if (error.code === "ER_DUP_ENTRY") {
                throw {
                    status: 400,
                    message: `An account with the given email already exists`,
                };
            }
            throw error;
        });

        return results;
    }

    async updateUser(user_id: string, userData: Partial<UserDB>, transaction?: PoolConnection): Promise<ResultSetHeader> {
        const connection = transaction ?? connectionPool;

        /* ONLY ALLOW UPDATE PASSWORD FROM UPDATE PASSWORD FUNCTION */
        if (userData.password) {
            throw {
                error: "Updating password in updateUser",
            };
        }

        const setClause = Object.keys(userData)
            .map((key) => `${key} = ?`)
            .join(", ");
        const query = `UPDATE users SET ${setClause} WHERE user_id = ?`;
        const values = [...Object.values(userData), user_id];

        const [results, _] = await connection.query<ResultSetHeader>(query, values);

        return results
    }

    async deleteUser(user_id: string): Promise<void> {
        const transaction = await connectionPool.getConnection();

        try {
            const user = await this.getUserById(user_id);

            // Delete profile photo before user
            if (user.fk_image_id) {
                await imageModel.deleteImage(user.fk_image_id, transaction);
            }

            const query = `DELETE FROM users WHERE user_id = ?`;
            const values = [user_id];

            await transaction.query<ResultSetHeader>(query, values);

            await transaction.commit();
        } catch (error) {
            // Rollback
            await transaction.rollback();
            throw error;
        }
    }

    async upsertUserProfileImage(user_id: string, image: Buffer): Promise<string> {
        const transaction = await connectionPool.getConnection();

        // Process image
        const processedImage = await sharp(image)
            .resize({ width: 300, fit: 'outside'})
            .rotate()
            .toFormat('webp')
            .webp({ quality: 80 })
            .toBuffer();

        try {
            const user = await this.getUserById(user_id);

            // Delete old if exists
            if (user.fk_image_id) {
                await imageModel.deleteImage(user.fk_image_id, transaction);
            }

            const imageId = await imageModel.uploadImage(processedImage, transaction);
            await this.updateUser(user_id, { fk_image_id: imageId } as UserDB, transaction);

            await transaction.commit();

            return imageId;
        } catch (error) {
            // Rollback
            await transaction.rollback();
            throw error;
        }
    }

    async updateUserPassword(user_id: string, password: string, transaction?: PoolConnection): Promise<ResultSetHeader> {
        const connection = transaction ?? connectionPool;

        const query = `UPDATE users SET password = ? WHERE user_id = ?`;
        const values = [password, user_id];

        const [results, _] = await connection.query<ResultSetHeader>(query, values);

        return results
    }
}

================
File: src/models/volunteerModel.ts
================
import { PoolConnection, ResultSetHeader } from "mysql2/promise";
import { ShiftDB, VolunteerDB } from "../common/databaseModels.js";
import connectionPool from "../config/database.js";

export default class VolunteerModel {
    async getVolunteersByIds(volunteer_ids: string | string[]): Promise<VolunteerDB[]> {
        if (typeof volunteer_ids === 'string') {
            volunteer_ids = [volunteer_ids];
        }

        if (volunteer_ids.length === 0) {
            return [];
        }

        const query = `
            SELECT 
                v.*, u.created_at, u.f_name, u.l_name, u.email, u.fk_image_id
            FROM 
                volunteers v
            JOIN 
                users u ON v.fk_user_id = u.user_id
            WHERE 
                volunteer_id IN (?)
            `;
        const values = [volunteer_ids];

        const [results] = await connectionPool.query<VolunteerDB[]>(query, values);

        return results;
    }

    async getVolunteerByUserId(user_id: string): Promise<VolunteerDB> {
        const query = `
            SELECT 
                v.*, u.created_at, u.f_name, u.l_name, u.email, u.fk_image_id
            FROM 
                volunteers v
            JOIN 
                users u ON v.fk_user_id = u.user_id
            WHERE 
                u.user_id = ?
            `;
        const values = [user_id];

        const [results, _] = await connectionPool.query<VolunteerDB[]>(query, values);

        if (results.length === 0) {
            throw {
                status: 400,
                message: `No volunteer found under the given ID`,
            };
        }

        return results[0];
    }

    async getAllVolunteers(): Promise<VolunteerDB[]> {
        const query = `
            SELECT 
                v.*, u.created_at, u.f_name, u.l_name, u.email, u.fk_image_id
            FROM 
                volunteers v
            JOIN 
                users u ON v.fk_user_id = u.user_id
            `;

        const [results, _] = await connectionPool.query<VolunteerDB[]>(query, []);

        return results;
    }

    async getUnverifiedVolunteers(): Promise<VolunteerDB[]> {
        const query = `
            SELECT 
                v.*, u.created_at, u.f_name, u.l_name, u.email, u.fk_image_id
            FROM 
                volunteers v
            JOIN 
                users u ON v.fk_user_id = u.user_id
            WHERE
                active = false
            `;

        const [results, _] = await connectionPool.query<VolunteerDB[]>(query, []);

        return results
    }

    async updateVolunteer(volunteer_id: string, volunteerData: Partial<VolunteerDB>): Promise<ResultSetHeader> {
        // Construct the SET clause dynamically
        const setClause = Object.keys(volunteerData)
            .map((key) => `${key} = ?`)
            .join(", ");
        const query = `UPDATE volunteers SET ${setClause} WHERE volunteer_id = ?`;
        const values = [...Object.values(volunteerData), volunteer_id];

        const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

        return results
    }

    async insertVolunteer(volunteer: VolunteerDB, transaction?: PoolConnection): Promise<any> {
        const connection = transaction ?? connectionPool;
        
        // Construct the INSERT clause dynamically
        const insertClause = Object.keys(volunteer)
            .join(", ");
        const valuesClause = Object.keys(volunteer)
            .map(_ => '?')
            .join(", ");
        const query = `INSERT INTO volunteers (${insertClause}) VALUES (${valuesClause})`;
        const values = Object.values(volunteer);

        const [results, _] = await connection.query<ResultSetHeader>(query, values);

        return results
    }

    async deleteVolunteer(user_id: string): Promise<any> {
        const query = "DELETE FROM volunteers WHERE user_id = ?";
        const values = [user_id];

        const [results, _] = await connectionPool.query<ResultSetHeader>(query, values);

        return results;
    }

    async shiftCheckIn(volunteer_id: string, fk_schedule_id: any, shift_date: any): Promise<void> {
        const query1 = `SELECT duration FROM shifts WHERE fk_volunteer_id = ? AND fk_schedule_id = ? AND shift_date = ?`;
        const values1 = [volunteer_id, fk_schedule_id, shift_date];
            
        const [results] = await connectionPool.query<ShiftDB[]>(query1, values1);

        if (results.length === 0) {
            throw {
                status: 400,
                message: `No shift found for the given volunteer and schedule.`,
            };
        }
        const duration = results[0].duration;

        // Get the volunteer's current hours
        const query2 = "SELECT total_hours FROM volunteers WHERE volunteer_id = ?";
        const values2 = [volunteer_id];

        const [results2] = await connectionPool.query<VolunteerDB[]>(query2, values2);

        if (results2.length == 0) {
            throw {
                status: 400,
                message: `No volunteer found under the given ID`,
            };
        }

        const hours_so_far = results2[0].total_hours;
        const new_total_hours = hours_so_far ?? 0 + duration;

        // Update volunteer hours and shift check-in in a single query
        const updateQuery = `
            UPDATE volunteers v
            JOIN shifts s ON s.fk_volunteer_id = v.volunteer_id
            SET 
                v.total_hours = ?,
                s.checked_in = 1
            WHERE 
                v.volunteer_id = ? AND
                s.fk_schedule_id = ? AND
                s.shift_date = ?
        `;
        const updateValues = [new_total_hours, volunteer_id, fk_schedule_id, shift_date];

        const [updateResults] = await connectionPool.query<ResultSetHeader>(updateQuery, updateValues);

        if (updateResults.affectedRows === 0) {
            throw {
                status: 400,
                message: `No rows updated. Verify all parameters.`,
            };
        }
    }

    async getPreferredClassesById(volunteer_id: string): Promise<any> {

        const query = `
            SELECT 
                class_preferences.fk_volunteer_id AS volunteer_id,
                class_preferences.fk_schedule_id AS schedule_id,
                class_preferences.class_rank,
                schedule.fk_class_id AS class_id,
                schedule.day, schedule.start_time, schedule.end_time,
                class.class_name, class.instructions, class.category, class.subcategory
            FROM class_preferences
            JOIN schedule ON class_preferences.fk_schedule_id = schedule.schedule_id
            JOIN class ON schedule.fk_class_id = class.class_id
            WHERE class_preferences.fk_volunteer_id = ?; 
        `;
        const values = [volunteer_id];
        const [results, _] = await connectionPool.query<any>(query, values);
        return results;
    }

    async getAllClassPreferences(): Promise<any> {

        const query = `
            SELECT 
                s.schedule_id, s.fk_class_id, s.day, s.start_time, s.end_time, s.active, 
                c.class_name, c.instructions, c.category, 
                i.f_name, i.l_name
            FROM schedule AS s
            JOIN class AS c ON s.fk_class_id = c.class_id 
            JOIN instructors AS i ON c.fk_instructor_id = i.instructor_id
            WHERE s.active = 1; 
        `;

        const [results, _] = await connectionPool.query<any>(query, []);
        return results;
    }

    async updatePreferredClassesById(volunteer_id: string, data: { schedule_id: number, class_rank: number }[] ): Promise<void> {
        const transaction = await connectionPool.getConnection();
   
        try {
            await transaction.beginTransaction();
            const query_del = `DELETE FROM class_preferences WHERE fk_volunteer_id = ?`;
            const values_del = [volunteer_id];
            await transaction.query<ResultSetHeader>(query_del, values_del);
            const query_insert = `INSERT INTO class_preferences VALUES (?, ?, ?);`;

            for (let i = 0; i < data.length; i++) {
                const value_insert = [volunteer_id, data[i].schedule_id, data[i].class_rank];
                await transaction.query<ResultSetHeader>(query_insert, value_insert);
            }

            await transaction.commit();
        } catch (error) {
             // Rollback
            await transaction.rollback();
            throw error;
        } finally {
            transaction.release(); 
        }
   }
}

================
File: src/routes/adminRoutes.ts
================
import { body } from "express-validator";
import { RouteDefinition } from "../common/types.js";
import { isAdmin, isAuthorized } from "../config/authCheck.js";
import {
    getUnverifiedVolunteers,
    verifyVolunteer,
} from "../controllers/adminController.js";

export const AdminRoutes: RouteDefinition = {
    path: '/admin',
    middleware: [
        isAuthorized,
        isAdmin,
    ],
    children: [
        {
            path: '/unverified-volunteers',
            method: 'post',
            action: getUnverifiedVolunteers
        },
        {
            path: '/verify-volunteer',
            method: 'post',
            validation: [
                body('volunteer_id').isUUID('4')
            ],
            action: verifyVolunteer
        },
    ]
};

================
File: src/routes/authRoutes.ts
================
import { body, param } from "express-validator";
import { Role } from "../common/interfaces.js";
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from "../config/authCheck.js";
import {
    checkAuthorization,
    loginUser,
    registerUser,
    resetPassword,
    sendResetPasswordEmail,
    updatePassword,
    verifyAndRedirect
} from "../controllers/authController.js";

export const AuthRoutes: RouteDefinition = {
    path: '/auth',
    children: [
        {
            path: '/register',
            method: 'post',
            validation: [
                body('firstName').isString(),
                body('lastName').isString(),
                body('email').isEmail(),
                body('password').isString(),
                body('role').isIn([Role.admin, Role.volunteer, Role.instructor]),
            ],
            action: registerUser
        },
        {
            path: '/login',
            method: 'post',
            validation: [
                body('email').isEmail(),
                body('password').isString(),
            ],
            action: loginUser
        },
        {
            path: '/send-reset-password-email',
            method: 'post',
            validation: [
                body('email').isEmail(),
            ],
            action: sendResetPasswordEmail
        },
        {
            path: '/forgot-password/:id/:token',
            method: 'get',
            validation: [
                param('id').isUUID('4'),
                param('token').isJWT(),
            ],
            action: verifyAndRedirect
        },
        {
            path: '/reset-password',
            method: 'post',
            validation: [
                body('token').isJWT(),
                body('id').isUUID('4'),
                body('password').isString(),
            ],
            action: resetPassword
        },
        {
            path: '/update-password',
            method: 'post',
            middleware: [isAuthorized],
            validation: [
                body('currentPassword').isString(),
                body('newPassword').isString(),
            ],
            action: updatePassword
        },
        {
            path: '/is-authenticated',
            method: 'get',
            middleware: [isAuthorized],
            action: checkAuthorization
        },
    ]
};

================
File: src/routes/classRoutes.ts
================
import { body, param } from 'express-validator';
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from '../config/authCheck.js';
import { imageUploadMiddleware } from '../config/fileUpload.js';
import { addClass, deleteClass, getAllClasses, getClassById, getClassesByDay, updateClass, uploadClassImage } from '../controllers/classController.js';

export const ClassRoutes: RouteDefinition = {
    path: '/classes',
    middleware: [
        isAuthorized,
    ],
    children: [
        {
            path: '/',
            method: 'get',
            action: getAllClasses
        },
        {
            path: '/',
            method: 'post',
            validation: [
                body('fk_instructor_id').isUUID('4'),
                body('class_name').isString(),
                body('instructions').isString().optional(),
                body('zoom_link').isURL().optional(),
                body('start_date').isDate({ format: 'YYYY-MM-DD' }),
                body('end_date').isDate({ format: 'YYYY-MM-DD' }),
                body('category').isString().optional(),
                body('subcategory').isString().optional(),
                body('schedules').isArray({ min: 1 }).optional(),
                body('schedules.*.day').isInt({ min: 0, max: 6 }),
                body('schedules.*.start_time').isTime({ hourFormat: 'hour24' }),
                body('schedules.*.end_time').isTime({ hourFormat: 'hour24' }),
                body('schedules.*.volunteer_ids').isArray({ min: 1 }).optional(),
                body('schedules.*.volunteer_ids.*').isUUID('4')
            ],
            action: addClass
        },
        {
            path: '/schedule/:day',
            method: 'get',
            validation: [
                param('day').isDate({ format: 'YYYY-MM-DD' }),
            ],
            action: getClassesByDay
        },
        {
            path: '/:class_id',
            validation: [
                param('class_id').isInt({ min: 0 })
            ],
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getClassById
                },
                {
                    path: '/',
                    method: 'put',
                    validation: [
                        body('fk_instructor_id').isUUID('4').optional(),
                        body('class_name').isString().optional(),
                        body('instructions').isString().optional(),
                        body('zoom_link').isURL().optional(),
                        body('start_date').isDate({ format: 'YYYY-MM-DD' }).optional(),
                        body('end_date').isDate({ format: 'YYYY-MM-DD' }).optional(),
                        body('category').isString().optional(),
                        body('subcategory').isString().optional(),
                    ],
                    action: updateClass
                },
                {
                    path: '/',
                    method: 'delete',
                    action: deleteClass
                },
                {
                    path: '/upload',
                    method: 'put',
                    middleware: [imageUploadMiddleware],
                    action: uploadClassImage
                }
            ]
        },
    ]
};

================
File: src/routes/imageRoutes.ts
================
import { param } from "express-validator";
import { RouteDefinition } from "../common/types.js";
import { getImage } from "../controllers/imageController.js";

export const ImageRoutes: RouteDefinition = {
    path: '/image/:image_id',
    method: 'get',
    validation: [
        param('image_id').isUUID('4')
    ],
    action: getImage
}

================
File: src/routes/instructorRoutes.ts
================
import { body, param } from 'express-validator';
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from '../config/authCheck.js';
import {
    getInstructorById,
    getInstructors,
    insertInstructor
} from '../controllers/instructorController.js';

export const InstructorRoutes: RouteDefinition = {
    path: '/instructors',
    middleware: [
        isAuthorized,
    ],
    children: [
        {
            path: '/',
            method: 'get',
            action: getInstructors
        },
        {
            path: '/',
            method: 'post',
            validation: [
                body('instructor_id').isUUID('4'),
                body('f_name').isString(),
                body('l_name').isString(),
                body('email').isEmail(),
            ],
            action: insertInstructor
        },
        {
            path: '/:instructor_id',
            method: 'get',
            validation: [
                param('instructor_id').isUUID('4')
            ],
            action: getInstructorById
        },
    ]
};

================
File: src/routes/routes.ts
================
import { RouteDefinition } from "../common/types.js";
import { AdminRoutes } from './adminRoutes.js';
import { AuthRoutes } from './authRoutes.js';
import { ClassRoutes } from './classRoutes.js';
import { ImageRoutes } from './imageRoutes.js';
import { InstructorRoutes } from './instructorRoutes.js';
import { ScheduleRoutes } from './scheduleRoutes.js';
import { ShiftRoutes } from './shiftRoutes.js';
import { UserRoutes } from './userRoutes.js';
import { VolunteerRoutes } from './volunteerRoutes.js';

export const Routes: RouteDefinition[] = [
    AdminRoutes,
    AuthRoutes,
    ClassRoutes,
    ImageRoutes,
    InstructorRoutes,
    ScheduleRoutes,
    ShiftRoutes,
    UserRoutes,
    VolunteerRoutes
]

================
File: src/routes/scheduleRoutes.ts
================
import { body, param } from 'express-validator';
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from '../config/authCheck.js';
import {
    addSchedulesToClass,
    assignVolunteersToSchedule,
    deleteOrSoftDeleteSchedules,
    deleteSchedulesFromClass,
    getActiveSchedulesForClass,
    getAllSchedules,
    updateSchedulesForClass
} from '../controllers/scheduleController.js';

export const ScheduleRoutes: RouteDefinition = {
    path: '/schedules',
    middleware: [
        isAuthorized,
    ],
    children: [
        {
            path: '/',
            method: 'get',
            action: getAllSchedules
        },
        {
            path: '/:class_id',
            validation: [
                param('class_id').isInt({ min: 1 })
            ],
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getActiveSchedulesForClass
                },
                {
                    path: '/',
                    method: 'post',
                    validation: [
                        body().isArray({ min: 1 }),
                        body('*.day').isInt({ min: 0, max: 6 }),
                        body('*.start_time').isTime({ hourFormat: 'hour24' }),
                        body('*.end_time').isTime({ hourFormat: 'hour24' }),
                        body('*.volunteer_ids').isArray({ min: 1 }).optional(),
                        body('*.volunteer_ids.*').isUUID('4')
                    ],
                    action: addSchedulesToClass
                },
                {
                    path: '/',
                    method: 'put',
                    validation: [
                        body().isArray({ min: 1 }),
                        body('*.schedule_id').isInt({ min: 1 }),
                        body('*.day').isInt({ min: 0, max: 6 }),
                        body('*.start_time').isTime({ hourFormat: 'hour24' }),
                        body('*.end_time').isTime({ hourFormat: 'hour24' }),
                        body('*.volunteer_ids').isArray({ min: 0 }).optional(),
                        body('*.volunteer_ids.*').isUUID('4')
                    ],
                    action: updateSchedulesForClass
                },
                {
                    path: '/',
                    method: 'delete',
                    validation: [
                        body('schedule_ids').isArray({ min: 1 }),
                        body('schedule_ids.*').isInt({ min: 1 }),
                    ],
                    action: deleteSchedulesFromClass
                },
                {
                    path: '/soft-option',
                    method: 'delete',
                    validation: [
                        body('schedule_ids').isArray({ min: 1 }),
                        body('schedule_ids.*').isInt({ min: 1 }),
                    ],
                    action: deleteOrSoftDeleteSchedules
                },
                {
                    path: '/:schedule_id',
                    method: 'post',
                    validation: [
                        param('schedule_id').isInt({ min: 1}),
                        body('volunteer_ids').isArray({ min: 1 }),
                        body('volunteer_ids.*').isUUID('4')
                    ],
                    action: assignVolunteersToSchedule
                }
            ]
        },
    ]
};

================
File: src/routes/shiftRoutes.ts
================
import { body, param } from 'express-validator';
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from '../config/authCheck.js';
import {
    addShift,
    checkInShift,
    deleteShift,
    getShift,
    getShifts,
    getShiftsByVolunteerIdAndMonth,
    requestCoverShift,
    requestShiftCoverage,
    updateShift,
    withdrawCoverShift,
    withdrawShiftCoverage
} from '../controllers/shiftController.js';

export const ShiftRoutes: RouteDefinition = {
    path: '/shifts',
    middleware: [
        isAuthorized,
    ],
    children: [
        {
            path: '/',
            method: 'post',
            validation: [
                body('fk_volunteer_id').isUUID('4'),
                body('shift_date').isDate({ format: 'YYYY-MM-DD' }),
                body('fk_schedule_id').isInt({ min: 0 }),
                body('duration').isInt({ min: 0 }),
            ],
            action: addShift
        },
        {
            path: '/',
            method: 'get',
            validation: [
                param('volunteer').isUUID('4'),
                param('before').isDate(),
                param('after').isDate(),
                param('type').isIn(['coverage', 'request'])
            ],
            action: getShifts
        },

        {
            // Retrieves all shifts viewable to a specific volunteer in a given month and year.
            // -- The shifts include:
            // -- 1. 'my-shifts' - shifts assigned to the volunteer.
            // -- 2. 'coverage' - shifts available for coverage by other volunteers.
            // -- 3. 'my-coverage-requests' - coverage requests made by the volunteer.
            // -- Returns shift details such as date, time, class, duration, and coverage status.
            path: '/volunteer-month',
            method: 'post',
            validation: [
                body('shift_date').isDate({ format: 'YYYY-MM-DD' }),
                body('fk_volunteer_id').isUUID('4')
            ],
            action: getShiftsByVolunteerIdAndMonth
        },
        //

        {
            path: '/check-in/:shift_id',
            method: 'patch',
            validation: [
                param('shift_id').isInt({ min: 0 })
            ],
            action: checkInShift
        },
        {
            path: '/cover-shift',
            method: 'post',
            validation: [
                body('request_id').isInt({ min: 0 }),
                body('volunteer_id').isUUID('4')
            ],
            action: requestCoverShift
        },
        {
            path: '/cover-shift',
            method: 'delete',
            validation: [
                body('request_id').isInt({ min: 0 }),
                body('volunteer_id').isUUID('4')
            ],
            action: withdrawCoverShift
        },
        {
            path: '/shift-coverage-request',
            method: 'put',
            validation: [
                body('shift_id').isInt({ min: 0 }),
            ],
            action: requestShiftCoverage
        },
        {
            path: '/shift-coverage-request',
            method: 'delete',
            validation: [
                body('request_id').isInt({ min: 0 }),
                body('shift_id').isInt({ min: 0 }),
            ],
            action: withdrawShiftCoverage
        },
        {
            path: '/:shift_id',
            validation: [
                param('shift_id').isInt({ min: 0 })
            ],
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getShift
                },
                {
                    path: '/',
                    method: 'put',
                    validation: [
                        body('fk_volunteer_id').isUUID('4').optional(),
                        body('shift_date').isDate({ format: 'YYYY-MM-DD' }).optional(),
                        body('duration').isInt({ min: 0 }).optional(),
                    ],
                    action: updateShift
                },
                {
                    path: '/',
                    method: 'put',
                    action: deleteShift
                },
            ]
        }
    ]
};

================
File: src/routes/userRoutes.ts
================
import { param } from "express-validator";
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from "../config/authCheck.js";
import { imageUploadMiddleware } from "../config/fileUpload.js";
import { getUserById, insertProfilePicture } from "../controllers/userController.js";

export const UserRoutes: RouteDefinition = {
    path: '/user/:user_id',
    middleware: [
        isAuthorized,
    ],
    validation: [
        param('user_id').isUUID('4')
    ],
    children: [
        {
            path: '/',
            method: 'get',
            action: getUserById
        },
        {
            path: '/upload',
            method: 'post',
            middleware: [imageUploadMiddleware],
            action: insertProfilePicture
        },
    ]
};

================
File: src/routes/volunteerRoutes.ts
================
import { Request, Response, Router } from "express";
import multer from 'multer';

import {
    getVolunteerById,
    getVolunteers,
    shiftCheckIn,
    updateVolunteer,
    getPreferredClassesById,
    getAllClassPreferences,
    updatePreferredClassesById
} from "../controllers/volunteerController.js";

import { body, param } from "express-validator";
import { RouteDefinition } from "../common/types.js";
import { isAuthorized } from "../config/authCheck.js";
import {
    getAvailabilities,
    getAvailabilityByVolunteerId,
    setAvailabilityByVolunteerId,
    updateAvailabilityByVolunteerId,
} from "../controllers/availabilityController.js";

export const VolunteerRoutes: RouteDefinition = {
    path: '/volunteer',
    middleware: [
        isAuthorized,
    ],
    children: [
        {
            path: '/',
            method: 'get',
            action: getVolunteers
        },
        {
            path: '/shift-check-in',
            method: 'post',
            validation: [
                body('volunteer_id').isUUID('4'),
                body('fk_schedule_id').isInt({ min: 0 }),
                body('shift_date').isDate({ format: 'YYYY-MM-DD'}),
            ],
            action: shiftCheckIn
        },
        {
            path: '/availability',
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getAvailabilities
                },
                {
                    path: '/:volunteer_id',
                    validation: [
                        param('volunteer_id').isUUID('4')
                    ],
                    children: [
                        {
                            path: '/',
                            method: 'get',
                            action: getAvailabilityByVolunteerId
                        },
                        {
                            path: '/',
                            method: 'put',
                            validation: [
                                body().isArray({ min: 0 }),
                                body('*.day').isInt({ min: 1, max: 7 }),
                                body('*.start_time').isTime({ hourFormat: 'hour24' }),
                                body('*.end_time').isTime({ hourFormat: 'hour24' }),
                            ],
                            action: updateAvailabilityByVolunteerId
                        },
                        {
                            path: '/',
                            method: 'post',
                            validation: [
                                body().isArray({ min: 0 }),
                                body('*.day').isInt({ min: 1, max: 7 }),
                                body('*.start_time').isTime({ hourFormat: 'hour24' }),
                                body('*.end_time').isTime({ hourFormat: 'hour24' }),
                            ],
                            action: setAvailabilityByVolunteerId
                        },
                    ]
                },
            ]
        },
        {
            path: '/class-preferences',
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getAllClassPreferences
                },
                {
                    path: '/:volunteer_id',
                    validation: [
                        param('volunteer_id').isUUID('4')
                    ],
                    children: [
                        {
                            path: '/',
                            method: 'get',
                            action: getPreferredClassesById
                        }, 
                        {
                            path: '/',
                            method: 'put',
                            action: updatePreferredClassesById
                        }
                    ]
                }
            ]
        },
        {
            path: '/:volunteer_id',
            validation: [
                param('volunteer_id').isUUID('4')
            ],
            children: [
                {
                    path: '/',
                    method: 'get',
                    action: getVolunteerById
                },
                {
                    path: '/',
                    method: 'put',
                    validation: [
                        body('p_name').isString().optional(),
                        body('f_name').isString().optional(),
                        body('l_name').isString().optional(),
                        body('total_hours').isInt().optional(),
                        body('bio').isString().optional(),
                        body('pronouns').optional(),
                        body('email').isEmail().optional(),
                        body('active').isInt().optional(),
                        body('phone_number').isMobilePhone('en-US').optional(),
                        body('city').isString().optional(),
                        body('province').isString().optional(),
                        body('p_time_ctmt').isInt({ min: 0 }).optional(),
                    ],
                    action: updateVolunteer
                },
            ]
        },
    ]
};

================
File: src/utils/routeUtils.ts
================
import { Express, NextFunction, Request, Response, Router } from "express";
import { validationResult } from "express-validator";
import { RouteDefinition, RouteEndpoint, RouteGroup } from "../common/types.js";

export function registerRoutes(app: Express | Router, routes: RouteDefinition[]) {
    routes.forEach((route) => {
        if (isRouteGroup(route)) {
            const middlewares = [
                ...(route.middleware || []),
                ...(route.validation || [])
            ];

            const groupRouter: Router = Router({ mergeParams: true });

            if (middlewares.length > 0) {
                groupRouter.use(...middlewares);
            }

            // Recursively register child routes and then register router to app
            registerRoutes(groupRouter, route.children);
            app.use(route.path, groupRouter as Express);
        }
        else if (isRouteEndpoint(route)) {
            const middlewares = [
                ...(route.middleware || []),
                ...(route.validation || [])
            ];

            (app as any)[route.method](route.path, ...middlewares, async (req: Request, res: Response, next: NextFunction) => {
                const errors = validationResult(req);
                if (!errors.isEmpty()) {
                    /* If there are validation errors, send a response with the error messages */
                    return res.status(400).json({ errors: errors.array({ onlyFirstError: true }) });
                }

                try {
                    return await route.action(
                        req,
                        res,
                        next,
                    );
                } catch (err: any) {
                    /* Send specific errors to the frontend */
                    if (err.status) {
                        res.status(err.status)
                        
                        if (err.message) {
                            res.json({
                                error: err.message
                            });
                        }
                        
                        return res;
                    }

                    console.error(err);
                    return res.sendStatus(500); // Don't expose internal server workings
                }
            });
        }
    });
}

// Helpers for type narrowing
function isRouteGroup(route: RouteDefinition): route is RouteGroup {
    return (route as RouteGroup).children !== undefined;
}

function isRouteEndpoint(route: RouteDefinition): route is RouteEndpoint {
    return (route as RouteEndpoint).method !== undefined && (route as RouteEndpoint).action !== undefined;
}

================
File: src/index.ts
================
// backend/index.ts
import bodyParser from "body-parser";
import cors from "cors";
import express, { Request, Response } from "express";
import morgan from 'morgan';
import { Routes } from "./routes/routes.js";
import { registerRoutes } from "./utils/routeUtils.js";

// set default port to be 3001
const PORT: number = parseInt(process.env.PORT || "3001", 10);
const ENVIRONMENT: string = process.env.NEURON_ENV || 'development';
const app = express();

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());
app.use(morgan('tiny', {
  skip: () => { 
    return ENVIRONMENT === 'production'; 
  },
})); 

app.get("/", (req: Request, res: Response) => {
  res.send({ message: "Hello Team Neuron!" });
});

// Register all routes
registerRoutes(app, Routes);

app.listen(PORT, () => {
  console.log(`Neuron backend server listening on ${PORT}`);
});

================
File: .example.env
================
RDS_HOSTNAME = "HOSTNAME",
RDS_USERNAME = "USERNAME",
RDS_PASSWORD = "PASSWORD",
RDS_PORT = 0000
RDS_DB = "DB NAME"

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

package-lock.json
/dist

================
File: generate-types.js
================
import { Client } from '@rmp135/sql-ts';
import { config as envConfig } from 'dotenv';
import { writeFile } from 'fs';

envConfig();

const config = {
    "client": "mysql2",
    "connection": {
        "host": process.env.RDS_HOSTNAME,
        "port": process.env.RDS_PORT,
        "user": process.env.RDS_USERNAME,
        "password": process.env.RDS_PASSWORD,
        "database" : process.env.RDS_DB
    },
    "tableNameCasing": "pascal",
    "interfaceNameFormat": "${table}DB",
    "singularTableNames": true,
    "filename": "./src/common/databaseModels.ts",
    "typeMap": {
        "Buffer": ["longblob", "mediumblob"],
        "string": ["time", "date"]
    }
};

let contents = await Client
    .fromConfig(config)
    .fetchDatabase()
    .mapTables((t) => {
        t.extends = "RowDataPacket"
        return t;
    })
    .toTypescript();

contents = `import { RowDataPacket } from "mysql2";

${contents}`

writeFile(config.filename, contents, err => {
    if (err) console.error(err)
});

================
File: package.json
================
{
  "name": "neuron-backend",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "src/index.ts",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "generate-schema": "node generate-types.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@rmp135/sql-ts": "^2.2.0",
    "@types/multer": "^1.4.12",
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.2",
    "knex": "^3.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "mysql": "^2.18.1",
    "mysql2": "^3.11.3",
    "nodemailer": "^6.9.15",
    "sharp": "^0.33.5",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/body-parser": "^1.19.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/mysql": "^2.15.26",
    "@types/node": "^22.7.4",
    "@types/nodemailer": "^6.4.16",
    "@types/sharp": "^0.31.1",
    "@types/uuid": "^10.0.0",
    "nodemon": "^3.1.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.1",
    "typescript": "^5.6.2"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2016",
    "module": "Node16",    
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "moduleResolution": "NodeNext",
    "forceConsistentCasingInFileNames": true,  
    "strict": true,
    "skipLibCheck": true,
    "declaration": true,
    "typeRoots": ["./node_modules/@types", "./src/common"]
  },
}
